<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kafka-python-api</title>
      <link href="/post/e5b7246f.html"/>
      <url>/post/e5b7246f.html</url>
      
        <content type="html"><![CDATA[<p>记一下之前一些学到的api吧,自己也要多看看官方文档,有时间也多看看英语吧!</p><div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://kafka.apache.org/documentation/">kafka官方</a></p><p><a href="https://kafka-python.readthedocs.io/en/master/apidoc/modules.html">Kafka-python帮助文档</a></p></div><h2 id="序列化与解码"><a href="#序列化与解码" class="headerlink" title="序列化与解码"></a>序列化与解码</h2><ul><li>编码（生产者）：value_serializer(key也是同样的写法)</li><li>解码（消费者）：value_deserializer(key也是同样的写法)</li></ul><ol><li><p>先看producer发送的json数据 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=[<span class="string">&#x27;localhost:9092&#x27;</span>], value_serializer=<span class="keyword">lambda</span> m: json.dumps(m).encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">future = producer.send(<span class="string">&#x27;my_topic&#x27;</span> ,  value= &#123;<span class="string">&#x27;value_1&#x27;</span> : <span class="string">&#x27;value_2&#x27;</span>&#125;, partition= <span class="number">0</span>)</span><br><span class="line">future.get(timeout= <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>consumer没有解码收到的数据 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConsumerRecord(topic=<span class="string">&#x27;my_topic&#x27;</span>, partition=<span class="number">0</span>, offset=<span class="number">22</span>, timestamp=<span class="number">1529575016310</span>, timestamp_type=<span class="number">0</span>, key=<span class="literal">None</span>, value=<span class="string">b&#x27;&#123;&quot;value_1&quot;: &quot;value_2&quot;&#125;&#x27;</span>, checksum=<span class="literal">None</span>, serialized_key_size=-<span class="number">1</span>, serialized_value_size=<span class="number">22</span>)</span><br></pre></td></tr></table></figure><p> 可以看到value为原始的json字节数据，接下来可以再做一步解码操作 </p></li><li><p>consumer自动解码 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(group_id= <span class="string">&#x27;group2&#x27;</span>, bootstrap_servers= [<span class="string">&#x27;localhost:9092&#x27;</span>], value_deserializer=<span class="keyword">lambda</span> m: json.loads(m.decode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line">consumer.subscribe(topics= [<span class="string">&#x27;my_topic&#x27;</span>, <span class="string">&#x27;topic_1&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure><p> 接收结果： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConsumerRecord(topic=<span class="string">&#x27;my_topic&#x27;</span>, partition=<span class="number">0</span>, offset=<span class="number">23</span>, timestamp=<span class="number">1529575235994</span>, timestamp_type=<span class="number">0</span>, key=<span class="literal">None</span>, value=&#123;<span class="string">&#x27;value_1&#x27;</span>: <span class="string">&#x27;value_2&#x27;</span>&#125;, checksum=<span class="literal">None</span>, serialized_key_size=-<span class="number">1</span>, serialized_value_size=<span class="number">22</span>)</span><br></pre></td></tr></table></figure><ul><li>可以看到接收结果中，value已经自动解码，并为字符串类型</li><li>不仅value可以json，key也可以，只需指定 key_deserializer</li></ul></li></ol><h2 id="发送字符串类型的key和value"><a href="#发送字符串类型的key和value" class="headerlink" title="发送字符串类型的key和value"></a>发送字符串类型的key和value</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">producer</button></li><li class="tab"><button type="button" data-href="#test1-2">consumer</button></li><li class="tab"><button type="button" data-href="#test1-3">可压缩消息</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=[<span class="string">&#x27;localhost:9092&#x27;</span>],key_serializer= <span class="built_in">str</span>.encode, value_serializer= <span class="built_in">str</span>.encode)</span><br><span class="line">future = producer.send(<span class="string">&#x27;my_topic&#x27;</span> ,  key= <span class="string">&#x27;key_3&#x27;</span>, value= <span class="string">&#x27;value_3&#x27;</span>, partition= <span class="number">0</span>)</span><br><span class="line">future.get(timeout= <span class="number">10</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p> 若想要消费者收到的为字符串类型，就需要解码操作，key_deserializer&#x3D; bytes.decode </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(group_id= <span class="string">&#x27;group2&#x27;</span>, bootstrap_servers= [<span class="string">&#x27;localhost:9092&#x27;</span>], key_deserializer= <span class="built_in">bytes</span>.decode, value_deserializer= <span class="built_in">bytes</span>.decode)</span><br><span class="line">consumer.subscribe(pattern= <span class="string">&#x27;^my.*&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><ul><li>若消息过大，还可压缩消息发送，可选值为 ‘gzip’, ‘snappy’, ‘lz4’, or None </li><li>compression_type&#x3D;’gzip’</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=[<span class="string">&#x27;localhost:9092&#x27;</span>], compression_type=<span class="string">&#x27;gzip&#x27;</span>)</span><br><span class="line">future = producer.send(<span class="string">&#x27;my_topic&#x27;</span> ,  key= <span class="string">b&#x27;key_3&#x27;</span>, value= <span class="string">b&#x27;value_3&#x27;</span>, partition= <span class="number">0</span>)</span><br><span class="line">future.get(timeout= <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>msgpack为MessagePack的简称，是高效二进制序列化类库，比json高效 </li><li>发送msgpack消息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">producer = KafkaProducer(value_serializer=msgpack.dumps)</span><br><span class="line">producer.send(<span class="string">&#x27;msgpack-topic&#x27;</span>, &#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="send方法"><a href="#send方法" class="headerlink" title="send方法"></a>send方法</h2><p>对于生产者着重于send方法，其余的方法多看文档，在官方文档中有许多可配置参数可以查看， </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#send用于向主题发送信息</span></span><br><span class="line">send(topic, value=<span class="literal">None</span>, key=<span class="literal">None</span>, headers=<span class="literal">None</span>, partition=<span class="literal">None</span>, timestamp_ms=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">topic (<span class="built_in">str</span>) – topic where the message will be published，指定向哪个主题发送消息。</span><br><span class="line">value (optional) – message value. Must be <span class="built_in">type</span> <span class="built_in">bytes</span>, <span class="keyword">or</span> be serializable to <span class="built_in">bytes</span> via configured value_serializer. If value <span class="keyword">is</span> <span class="literal">None</span>, key <span class="keyword">is</span> required <span class="keyword">and</span> message acts <span class="keyword">as</span> a ‘delete’. </span><br><span class="line">               <span class="comment">#value为要发送的消息值，必须为bytes类型，如果这个值为空，则必须有对应的key值，并且空值被标记为删除。可以通过配置value_serializer参数序列化为字节类型。</span></span><br><span class="line">key (optional) – a key to associate <span class="keyword">with</span> the message. Can be used to determine which partition to send the message to. If partition <span class="keyword">is</span> <span class="literal">None</span> (<span class="keyword">and</span> producer’s partitioner config <span class="keyword">is</span> left <span class="keyword">as</span> default), </span><br><span class="line">               then messages <span class="keyword">with</span> the same key will be delivered to the same partition (but <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>, partition <span class="keyword">is</span> chosen randomly). Must be </span><br><span class="line">                <span class="built_in">type</span> <span class="built_in">bytes</span>, <span class="keyword">or</span> be serializable to <span class="built_in">bytes</span> via configured key_serializer.</span><br><span class="line">　　　　　　　　 <span class="comment">#key与value对应的键值，必须为bytes类型。kafka根据key值确定消息发往哪个分区（如果分区被指定则发往指定的分区），具有相同key的消息被发往同一个分区，如果key</span></span><br><span class="line">               <span class="comment">#为NONE则随机选择分区，可以使用key_serializer参数序列化为字节类型。</span></span><br><span class="line">headers (optional) – a <span class="built_in">list</span> of header key value pairs. <span class="type">List</span> items are tuples of <span class="built_in">str</span> key <span class="keyword">and</span> <span class="built_in">bytes</span> value.</span><br><span class="line">               <span class="comment">#键值对的列表头部，列表项是str(key)和bytes(value)。</span></span><br><span class="line">timestamp_ms (<span class="built_in">int</span>, optional) – epoch milliseconds (<span class="keyword">from</span> Jan <span class="number">1</span> <span class="number">1970</span> UTC) to use <span class="keyword">as</span> the message timestamp. Defaults to current time.</span><br><span class="line">               <span class="comment">#时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消息发送成功，返回的是RecordMetadata的对象；否则的话引发KafkaTimeoutError异常</span></span><br></pre></td></tr></table></figure><p> 在进行实际测试前，先创建一个topics，利用控制台创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@test3 <span class="built_in">bin</span>]<span class="comment"># ./kafka-topics.sh --zookeeper=10.0.102.204:2181,10.0.102.214:2181 --create --topic kafkatest --replication-factor 3 --partitions 3</span></span><br><span class="line">Created topic <span class="string">&quot;kafkatest&quot;</span>.</span><br><span class="line">[root@test3 <span class="built_in">bin</span>]<span class="comment"># ./kafka-topics.sh --zookeeper=10.0.102.204:2181,10.0.102.214:2181 --list --topic kafkatest</span></span><br><span class="line">kafkatest</span><br><span class="line">[root@test3 <span class="built_in">bin</span>]<span class="comment"># ./kafka-topics.sh --zookeeper=10.0.102.204:2181,10.0.102.214:2181 --describe --topic kafkatest</span></span><br><span class="line">Topic:kafkatest    PartitionCount:<span class="number">3</span>    ReplicationFactor:<span class="number">3</span>    Configs:</span><br><span class="line">    Topic: kafkatest    Partition: <span class="number">0</span>    Leader: <span class="number">2</span>    Replicas: <span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>    Isr: <span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span></span><br><span class="line">    Topic: kafkatest    Partition: <span class="number">1</span>    Leader: <span class="number">3</span>    Replicas: <span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>    Isr: <span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    Topic: kafkatest    Partition: <span class="number">2</span>    Leader: <span class="number">1</span>    Replicas: <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>    Isr: <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">[root@test3 <span class="built_in">bin</span>]<span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主题有3个分区，3个复制系数，主题名为kafkatest.  </span></span><br></pre></td></tr></table></figure><p> 一个简易的生产者demo如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=[<span class="string">&quot;10.0.102.214:9092&quot;</span>])</span><br><span class="line"></span><br><span class="line">i = <span class="number">20</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    msg = <span class="string">&quot;producer1+%d&quot;</span> % i</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">    future = producer.send(<span class="string">&#x27;kafkatest&#x27;</span>, key=<span class="built_in">bytes</span>(<span class="built_in">str</span>(i), value=msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment">#result = future.get(timeout= 10)</span></span><br><span class="line"><span class="comment"># print(result)                      </span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">producer.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#就是一个简易的while循环，不停的向kafka发送消息，一定要注意send发送的key和value的值均为bytes类型。</span></span><br></pre></td></tr></table></figure><ul><li>future.get函数等待单条消息发送完成或超时，经测试，必须有这个函数，不然发送不出去，或用time.sleep代替</li></ul><p>一个消费者的demo接收上面生产者发送的数据。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(<span class="string">&quot;kafkatest&quot;</span>, bootstrap_servers=[<span class="string">&quot;10.0.102.204:9092&quot;</span>], auto_offset_reset=<span class="string">&#x27;latest&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    key = msg.key.decode(encoding=<span class="string">&quot;utf-8&quot;</span>)               <span class="comment">#因为接收到的数据时bytes类型，因此需要解码</span></span><br><span class="line">    value = msg.value.decode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s-%d-%d key=%s value=%s&quot;</span> % (msg.topic, msg.partition, msg.offset, key, value))</span><br><span class="line"></span><br><span class="line"><span class="comment">#这是一个阻塞的过程，当生产者有消息传来的时候，就会读取消息，若是没有消息就会阻塞等待</span></span><br><span class="line"><span class="comment">#auto_offset_reset参数表示重置偏移量，有两个取值，latest表示读取消息队列中最新的消息，另一个取值earliest表示读取最早的消息。</span></span><br></pre></td></tr></table></figure><h2 id="消费者群组"><a href="#消费者群组" class="headerlink" title="消费者群组"></a>消费者群组</h2><p>​一个群组里的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息。创建一个消费者群组如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者群组中有一个group_id参数，</span></span><br><span class="line">consumer = KafkaConsumer(<span class="string">&quot;kafkatest&quot;</span>, group_id=<span class="string">&quot;test1&quot;</span>, bootstrap_servers=[<span class="string">&quot;10.0.102.204:9092&quot;</span>], auto_offset_reset=<span class="string">&#x27;latest&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    key = msg.key.decode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    value = msg.value.decode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s-%d-%d key=%s value=%s&quot;</span> % (msg.topic, msg.partition, msg.offset, key, value))</span><br></pre></td></tr></table></figure><p> 在pycharm中把上面的代码复制一份，这样在一个test1群组中就有了两个消费者，同时执行。 </p><h2 id="poll-方法"><a href="#poll-方法" class="headerlink" title="poll()方法"></a>poll()方法</h2><p>从指定的主题&#x2F;分区中获取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">poll(timeout_ms=<span class="number">0</span>, max_records=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># Records are fetched and returned in batches by topic-partition. On each poll, consumer will try to use the last consumed offset as the starting offset and fetch sequentially. The last consumed offset can be manually set through seek() or automatically set as the last committed offset for the subscribed list of partitions.</span></span><br><span class="line"><span class="comment"># 通过主题-分区分批获取和返回记录，在每一个轮询中，消费者将会使用最后消费的偏移量作为开始然后顺序fetch数据。最后消费的偏移量可以使用seek()手动设置，或者自动设置为订阅</span></span><br><span class="line"><span class="comment"># 的分区列表的最后提交的偏移量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Incompatible with iterator interface – use one or the other, not both.</span></span><br><span class="line"><span class="comment"># 与迭代器的接口是对立的。</span></span><br><span class="line">timeout_ms (<span class="built_in">int</span>, optional) – Milliseconds spent waiting <span class="keyword">in</span> poll <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">not</span> available <span class="keyword">in</span> the buffer. If <span class="number">0</span>, returns immediately <span class="keyword">with</span> <span class="built_in">any</span> </span><br><span class="line">　　　　　　　　　　　　　　　　records that are available currently <span class="keyword">in</span> the buffer, <span class="keyword">else</span> returns empty. Must <span class="keyword">not</span> be negative. Default: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">max_records (<span class="built_in">int</span>, optional) – The maximum number of records returned <span class="keyword">in</span> a single call to poll(). Default: Inherit value <span class="keyword">from</span> max_poll_records. </span><br><span class="line">                            默认从max_poll_records继承值。</span><br></pre></td></tr></table></figure><p> 一个简答的实例从kafka拉取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(<span class="string">&quot;kafkatest&quot;</span>, bootstrap_servers=[<span class="string">&#x27;10.0.102.204:9092&#x27;</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = consumer.poll(timeout_ms=<span class="number">5</span>)      </span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果如下，返回的是一个字典，consumerRecord对象包含着消息的一些元数据信息</span></span><br><span class="line">&#123;TopicPartition(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">2</span>): [ConsumerRecord(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">2</span>, offset=<span class="number">21929</span>, timestamp=<span class="number">1545978879892</span>, timestamp_type=<span class="number">0</span>, key=<span class="string">b&#x27;138&#x27;</span>, value=<span class="string">b&#x27;producer1+138&#x27;</span>, checksum=-<span class="number">660348132</span>, serialized_key_size=<span class="number">3</span>, serialized_value_size=<span class="number">13</span>)]&#125;</span><br><span class="line">&#123;TopicPartition(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">0</span>): [ConsumerRecord(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">0</span>, offset=<span class="number">22064</span>, timestamp=<span class="number">1545978882893</span>, timestamp_type=<span class="number">0</span>, key=<span class="string">b&#x27;141&#x27;</span>, value=<span class="string">b&#x27;producer1+141&#x27;</span>, checksum=-<span class="number">1803506349</span>, serialized_key_size=<span class="number">3</span>, serialized_value_size=<span class="number">13</span>)], TopicPartition(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">2</span>): [ConsumerRecord(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">2</span>, offset=<span class="number">21930</span>, timestamp=<span class="number">1545978880892</span>, timestamp_type=<span class="number">0</span>, key=<span class="string">b&#x27;139&#x27;</span>, value=<span class="string">b&#x27;producer1+139&#x27;</span>, checksum=-<span class="number">1863433503</span>, serialized_key_size=<span class="number">3</span>, serialized_value_size=<span class="number">13</span>), ConsumerRecord(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">2</span>, offset=<span class="number">21931</span>, timestamp=<span class="number">1545978881893</span>, timestamp_type=<span class="number">0</span>, key=<span class="string">b&#x27;140&#x27;</span>, value=<span class="string">b&#x27;producer1+140&#x27;</span>, checksum=-<span class="number">280146643</span>, serialized_key_size=<span class="number">3</span>, serialized_value_size=<span class="number">13</span>)]&#125;</span><br><span class="line">&#123;TopicPartition(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">2</span>): [ConsumerRecord(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">2</span>, offset=<span class="number">21932</span>, timestamp=<span class="number">1545978884894</span>, timestamp_type=<span class="number">0</span>, key=<span class="string">b&#x27;143&#x27;</span>, value=<span class="string">b&#x27;producer1+143&#x27;</span>, checksum=<span class="number">1459018748</span>, serialized_key_size=<span class="number">3</span>, serialized_value_size=<span class="number">13</span>)]&#125;</span><br><span class="line">&#123;TopicPartition(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">1</span>): [ConsumerRecord(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">1</span>, offset=<span class="number">22046</span>, timestamp=<span class="number">1545978883894</span>, timestamp_type=<span class="number">0</span>, key=<span class="string">b&#x27;142&#x27;</span>, value=<span class="string">b&#x27;producer1+142&#x27;</span>, checksum=-<span class="number">2023137030</span>, serialized_key_size=<span class="number">3</span>, serialized_value_size=<span class="number">13</span>)], TopicPartition(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">0</span>): [ConsumerRecord(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">0</span>, offset=<span class="number">22065</span>, timestamp=<span class="number">1545978885894</span>, timestamp_type=<span class="number">0</span>, key=<span class="string">b&#x27;144&#x27;</span>, value=<span class="string">b&#x27;producer1+144&#x27;</span>, checksum=<span class="number">1999922748</span>, serialized_key_size=<span class="number">3</span>, serialized_value_size=<span class="number">13</span>)]&#125;</span><br></pre></td></tr></table></figure><h2 id="seek-方法"><a href="#seek-方法" class="headerlink" title="seek()方法"></a>seek()方法</h2><p>  手动指定拉取主题的偏移量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">seek(partition, offset)    </span><br><span class="line">    </span><br><span class="line">Manually specify the fetch offset <span class="keyword">for</span> a TopicPartition.</span><br><span class="line"></span><br><span class="line">Overrides the fetch offsets that the consumer will use on the <span class="built_in">next</span> poll(). If this API <span class="keyword">is</span> invoked <span class="keyword">for</span> the same partition more than once, </span><br><span class="line">the latest offset will be used on the <span class="built_in">next</span> poll().</span><br><span class="line"><span class="comment">#覆盖下一个消费者使用poll()拉取的偏移量。如果这个API对同一个分区执行了多次，那么最后一个次的结果将会被使用。</span></span><br><span class="line"></span><br><span class="line">Note: You may lose data <span class="keyword">if</span> this API <span class="keyword">is</span> arbitrarily used <span class="keyword">in</span> the middle of consumption to reset the fetch offsets.    </span><br><span class="line"><span class="comment">#如果在消费过程中任意使用此API以重置提取偏移，则可能会丢失数据。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例如下</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.position(TopicPartition(topic=<span class="string">&quot;kafkatest&quot;</span>,partition=<span class="number">1</span>))</span><br><span class="line"><span class="number">22103</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用seek()设置偏移量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.seek(partition=TopicPartition(<span class="string">&quot;kafkatest&quot;</span>,<span class="number">1</span>),offset=<span class="number">22222</span>)</span><br><span class="line"><span class="comment">#需要说明的是seek函数有一个partition参数，但是这个参数必须是TopicPartition类型的。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.position(TopicPartition(topic=<span class="string">&quot;kafkatest&quot;</span>,partition=<span class="number">1</span>))</span><br><span class="line"><span class="number">22222</span></span><br></pre></td></tr></table></figure><p> 与seek相关的还有两个方法： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">seek_to_beginning(*partitions)</span><br><span class="line"><span class="comment">#寻找分区最早可用的偏移量</span></span><br><span class="line">seek_to_end(*partitions)</span><br><span class="line"><span class="comment">#寻找分区最近可用的偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.seek_to_beginning(TopicPartition(<span class="string">&quot;kafkatest&quot;</span>,<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.seek_to_end(TopicPartition(<span class="string">&quot;kafkatest&quot;</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意这两个方法的参数都是TopicPartition类型。</span></span><br></pre></td></tr></table></figure><h2 id="subscribe-方法"><a href="#subscribe-方法" class="headerlink" title="subscribe()方法"></a>subscribe()方法</h2><p>  subscribe()方法，给当前消费者订阅主题。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Subscribe to a <span class="built_in">list</span> of topics, <span class="keyword">or</span> a topic regex pattern.</span><br><span class="line"><span class="comment">#订阅一个主体列表，或者主题的正则表达式</span></span><br><span class="line">Partitions will be dynamically assigned via a group coordinator. Topic subscriptions are <span class="keyword">not</span> incremental: this <span class="built_in">list</span> will replace the current assignment (<span class="keyword">if</span> there <span class="keyword">is</span> one).</span><br><span class="line"><span class="comment">#分区将会通过分区协调器自动分配。主题订阅不是增量的，这个列表将会替换已经存在的主题。</span></span><br><span class="line"></span><br><span class="line">This method <span class="keyword">is</span> incompatible <span class="keyword">with</span> assign().    </span><br><span class="line"><span class="comment">#这个方法与assign()方法是不兼容的。    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.subscription()                       <span class="comment">#当前消费者订阅的主题</span></span><br><span class="line">&#123;<span class="string">&#x27;lianxi&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.subscribe((<span class="string">&quot;kafkatest&quot;</span>,<span class="string">&quot;lianxi&quot;</span>))    <span class="comment">#订阅主题，会覆盖之前的主题</span></span><br><span class="line"><span class="comment"># 也可以使用正则</span></span><br><span class="line"><span class="comment">#consumer.subscribe(pattern= &#x27;^my.*&#x27;)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.subscription()                       <span class="comment">#可以看到已经覆盖</span></span><br><span class="line">&#123;<span class="string">&#x27;lianxi&#x27;</span>, <span class="string">&#x27;kafkatest&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="unsubscribe（）方法"><a href="#unsubscribe（）方法" class="headerlink" title="unsubscribe（）方法"></a>unsubscribe（）方法</h2><p>​unsubscribe（） ：取消订阅所有主题并清除所有已分配的分区。 </p><h2 id="assign-partitions-方法"><a href="#assign-partitions-方法" class="headerlink" title="assign(partitions)方法"></a>assign(partitions)方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manually assign a <span class="built_in">list</span> of TopicPartitions to this consumer.</span><br><span class="line"><span class="comment">#手动将TopicPartitions指定给此消费者。</span></span><br><span class="line"><span class="comment">#这个函数和subscribe函数不能同时使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.assign(TopicPartition(<span class="string">&quot;kafkatest&quot;</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><ul><li><p>手动分配partition</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> TopicPartition</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(group_id= <span class="string">&#x27;group2&#x27;</span>, bootstrap_servers= [<span class="string">&#x27;localhost:9092&#x27;</span>])</span><br><span class="line">consumer.assign([TopicPartition(topic= <span class="string">&#x27;my_topic&#x27;</span>, partition= <span class="number">0</span>)])</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure></li></ul><h2 id="assignment-方法"><a href="#assignment-方法" class="headerlink" title="assignment()方法"></a>assignment()方法</h2><ul><li><p>Get the TopicPartitions currently assigned to this consumer.</p></li><li><p>如果分区是使用assign()直接分配的，那么这将只返回先前分配的相同分区。如果使用subscribe()订阅了主题，那么这将给出当前分配给使用者的主题分区集（如果分配尚未发生，或者分区正在重新分配的过程中，则可能是None）</p></li></ul><h2 id="beginning-offsets-partitions"><a href="#beginning-offsets-partitions" class="headerlink" title="beginning_offsets(partitions)"></a>beginning_offsets(partitions)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Get the first offset <span class="keyword">for</span> the given partitions.     </span><br><span class="line"><span class="comment">#得到给定分区的第一个偏移量</span></span><br><span class="line"></span><br><span class="line">This method does <span class="keyword">not</span> change the current consumer position of the partitions.</span><br><span class="line"><span class="comment">#这个方法不会改变当前消费者的偏移量</span></span><br><span class="line">This method may block indefinitely <span class="keyword">if</span> the partition does <span class="keyword">not</span> exist. </span><br><span class="line"><span class="comment">#这个方法可能会阻塞，如果给定的分区没有出现。</span></span><br><span class="line"></span><br><span class="line">partitions参数仍然是TopicPartition类型。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.beginning_offsets(TopicPartition(<span class="string">&quot;kafkatest&quot;</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment">#这个方法在kafka-python-1.3.1中没有</span></span><br></pre></td></tr></table></figure><h2 id="close-autocommit-x3D-True"><a href="#close-autocommit-x3D-True" class="headerlink" title="close(autocommit&#x3D;True)"></a>close(autocommit&#x3D;True)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Close the consumer, waiting indefinitely <span class="keyword">for</span> <span class="built_in">any</span> needed cleanup. </span><br><span class="line"><span class="comment">#关闭消费者，阻塞等待所需要的清理。</span></span><br><span class="line"></span><br><span class="line">Keyword Arguments:</span><br><span class="line">     autocommit (<span class="built_in">bool</span>) – If auto-commit <span class="keyword">is</span> configured <span class="keyword">for</span> this consumer, this optional flag causes the consumer to attempt to commit <span class="built_in">any</span> </span><br><span class="line"> pending consumed offsets prior to close. Default: <span class="literal">True</span></span><br><span class="line">      <span class="comment">#如果为此使用者配置了自动提交，则此可选标志会导致使用者在关闭之前尝试提交任何待处理的消耗偏移量。默认值：True</span></span><br></pre></td></tr></table></figure><h2 id="commit-offsets-x3D-None"><a href="#commit-offsets-x3D-None" class="headerlink" title="commit(offsets&#x3D;None)"></a>commit(offsets&#x3D;None)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Commit offsets to kafka, blocking until success <span class="keyword">or</span> error.</span><br><span class="line"><span class="comment">#提交偏移量到kafka，阻塞直到成功或者出错</span></span><br><span class="line">这只向Kafka提交偏移量。使用此API提交的偏移量将在每次重新平衡之后的第一次取出时以及在启动时使用。因此，如果需要在Kafka以外的任何地方存储偏移，则不应该使用此API。</span><br><span class="line">为了避免在重新启动使用者时重新处理读取的最后一条消息，提交的偏移量应该是应用程序应该使用的下一条消息，即：last_offset+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Parameters:    </span><br><span class="line">    offsets (<span class="built_in">dict</span>, optional) – &#123;TopicPartition: OffsetAndMetadata&#125; <span class="built_in">dict</span> to commit <span class="keyword">with</span> the configured group_id. Defaults to </span><br><span class="line"> currently consumed offsets <span class="keyword">for</span> <span class="built_in">all</span> subscribed partitions.</span><br></pre></td></tr></table></figure><h2 id="commit-async-offsets-x3D-None-callback-x3D-None"><a href="#commit-async-offsets-x3D-None-callback-x3D-None" class="headerlink" title="commit_async(offsets&#x3D;None, callback&#x3D;None)"></a>commit_async(offsets&#x3D;None, callback&#x3D;None)</h2><ul><li>Commit offsets to kafka asynchronously, optionally firing callback.异步提交，可选择的触发回调，其余的和上面的commit一样。</li></ul><h2 id="committed-partition"><a href="#committed-partition" class="headerlink" title="committed(partition)"></a>committed(partition)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Get the last committed offset <span class="keyword">for</span> the given partition.</span><br><span class="line"></span><br><span class="line">This offset will be used <span class="keyword">as</span> the position <span class="keyword">for</span> the consumer <span class="keyword">in</span> the event of a failure.</span><br><span class="line"></span><br><span class="line">如果有问题的分区未分配给此使用者，或者使用者尚未初始化其已提交偏移量缓存，则此调用可能会阻止执行远程调用。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.committed(TopicPartition(<span class="string">&quot;kafkatest&quot;</span>,<span class="number">1</span>))</span><br><span class="line"><span class="number">22103</span></span><br></pre></td></tr></table></figure><h2 id="pase-pased和resume"><a href="#pase-pased和resume" class="headerlink" title="pase,pased和resume"></a>pase,pased和resume</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pase：暂停当前正在进行的请求。需要使用resume恢复</span><br><span class="line">pased：获取使用pase暂停时的分区信息</span><br><span class="line">resume： 从pase状态恢复。</span><br><span class="line">除了pased之外，其余两个方法的参数均为TopicPartation类型</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer = KafkaConsumer(<span class="string">&quot;kafkatest&quot;</span>, group_id=<span class="string">&quot;test1&quot;</span>, bootstrap_servers=[<span class="string">&quot;10.0.102.204:9092&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.topics()            <span class="comment">#获取主主题列表，返回的是一个set集合</span></span><br><span class="line">&#123;<span class="string">&#x27;kafkatest&#x27;</span>, <span class="string">&#x27;lianxi&#x27;</span>, <span class="string">&#x27;science&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.partitions_for_topic(<span class="string">&quot;kafkatest&quot;</span>)     <span class="comment">#获取主题的分区信息</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.subscription()      <span class="comment">#获取当前消费者订阅的主题</span></span><br><span class="line">&#123;<span class="string">&#x27;kafkatest&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.position((<span class="number">0</span>,))      <span class="comment">#得到下一个记录的偏移量</span></span><br><span class="line"></span><br><span class="line">TypeError: partition must be a TopicPartition namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment">#需要注意的是position方法需要传入的是一个kafka-python自带的一种数据结构TopicPartition，这种数据结构的定义如下，在使用的时候需要导入</span></span><br><span class="line">TopicPartition = namedtuple(<span class="string">&quot;TopicPartition&quot;</span>, [<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;partition&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>consumer.position(TopicPartition(topic=<span class="string">&#x27;kafkatest&#x27;</span>, partition=<span class="number">1</span>))</span><br><span class="line"><span class="number">17580</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Kafka </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka-python</title>
      <link href="/post/e8c1645.html"/>
      <url>/post/e8c1645.html</url>
      
        <content type="html"><![CDATA[<p>最近学了Kafka在Python中的使用,记一下笔记吧!</p><div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://kafka-python.readthedocs.io/en/master/apidoc/modules.html">Kafka-python API帮助文档</a></p></div><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><pre><code> KafkaProducer是发布消息到Kafka集群的客户端，它是线程安全的并且共享单一生产者实例。生产者包含一个带有缓冲区的池，用于保存还没有传送到Kafka集群的消息记录以及一个后台IO线程，该线程将这些留在缓冲区的消息记录发送到Kafka集群中。</code></pre><p>​要往Kafka写入消息，首先要创建一个生产者对象，并设置一些属性。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="keyword">from</span> kafka.errors <span class="keyword">import</span> KafkaError, KafkaTimeoutError</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">KafkaProducer构造函数部分参数解释</span></span><br><span class="line"><span class="string">    - acks 0表示发送不理睬发送是否成功；1表示需要等待leader成功写入日志才返回；all表示所有副本都写入日志才返回</span></span><br><span class="line"><span class="string">    - buffer_memory 默认33554432也就是32M，该参数用于设置producer用于缓存消息的缓冲区大小，如果采用异步发送消息，那么</span></span><br><span class="line"><span class="string">                    生产者启动后会创建一个内存缓冲区用于存放待发送的消息，然后由专属线程来把放在缓冲区的消息进行真正发送，</span></span><br><span class="line"><span class="string">                    如果要给生产者要给很多分区发消息那么就需要考虑这个参数的大小防止过小降低吞吐量</span></span><br><span class="line"><span class="string">    - compression_type 是否启用压缩，默认是none，可选类型为gzip、lz4、snappy三种。压缩会降低网络IO但是会增加生产者端的CPU</span></span><br><span class="line"><span class="string">                       消耗。另外如果broker端的压缩设置和生产者不同那么也会给broker带来重新解压缩和重新压缩的CPU负担。</span></span><br><span class="line"><span class="string">    - retries 重试次数，当消息发送失败后会尝试几次重发。默认为0，一般考虑到网络抖动或者分区的leader切换，而不是服务端</span></span><br><span class="line"><span class="string">              真的故障所以可以设置重试3次。</span></span><br><span class="line"><span class="string">    - retry_backoff_ms 每次重试间隔多少毫秒，默认100毫秒。</span></span><br><span class="line"><span class="string">    - max_in_flight_requests_per_connection 生产者会将多个发送请求缓存在内存中，默认是5个，如果你开启了重试，也就是设置了</span></span><br><span class="line"><span class="string">                                            retries参数，那么将可能导致针对于同一分区的消息出现顺序错乱。为了防止这种情况</span></span><br><span class="line"><span class="string">                                            需要把该参数设置为1，来保障同分区的消息顺序。</span></span><br><span class="line"><span class="string">    - batch_size 对于调优生产者吞吐量和延迟性能指标有重要的作用。buffer_memeory可以看做池子，而这个batch_size可以看做池子里</span></span><br><span class="line"><span class="string">                 装有消息的小盒子。这个值默认16384也就是16K，其实不大。生产者会把发往同一个分区的消息放在一个batch中，当batch</span></span><br><span class="line"><span class="string">                 满了就会发送里面的消息，但是也不一定非要等到满了才会发。这个数值大那么生产者吞吐量高但是性能低因为盒子太大占用内存</span></span><br><span class="line"><span class="string">                 发送的时候这个数据量也就大。如果你设置成1M，那么显然生产者的吞吐量要比16K高的多。</span></span><br><span class="line"><span class="string">    - linger_ms 上面说batch没有填满也可以发送，那显然有一个时间控制，就是这个参数，默认是0毫秒，这个参数就是用于控制消息发送延迟</span></span><br><span class="line"><span class="string">                多久的。默认是立即发送，无需关系batch是否填满。大多数场景我们希望立即发送，但是这也降低了吞吐量。</span></span><br><span class="line"><span class="string">    - max_request_size 最大请求大小，可以理解为一条消息记录的最大大小，默认是1048576字节。</span></span><br><span class="line"><span class="string">    - request_timeout_ms  生产者发送消息后，broker需要在规定时间内将处理结果返回给生产者，那个这个时间长度就是这个参数</span></span><br><span class="line"><span class="string">                          控制的，默认30000，也就是30秒。如果broker在30秒内没有给生产者响应，那么生产者就会认为请求超时，并在回调函数</span></span><br><span class="line"><span class="string">                          中进行特殊处理，或者进行重试。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, KafkaServerList=[<span class="string">&#x27;127.0.0.1:9092&#x27;</span>], ClientId=<span class="string">&quot;Procucer01&quot;</span>, Topic=<span class="string">&#x27;Test&#x27;</span></span>):</span><br><span class="line">        self._kwargs = &#123;</span><br><span class="line">            <span class="string">&quot;bootstrap_servers&quot;</span>: KafkaServerList,</span><br><span class="line">            <span class="string">&quot;client_id&quot;</span>: ClientId,</span><br><span class="line">            <span class="string">&quot;acks&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;buffer_memory&quot;</span>: <span class="number">33554432</span>,</span><br><span class="line">            <span class="string">&#x27;compression_type&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">            <span class="string">&quot;retries&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="string">&quot;batch_size&quot;</span>: <span class="number">1048576</span>,</span><br><span class="line">            <span class="string">&quot;linger_ms&quot;</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">&quot;key_serializer&quot;</span>: <span class="keyword">lambda</span> m:json.dumps(m).encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">            <span class="string">&quot;value_serializer&quot;</span>: <span class="keyword">lambda</span> m: json.dumps(m).encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        self._topic = Topic</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._producer = KafkaProducer(**self._kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(err)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_onSendSucess</span>(<span class="params">self, record_metadata</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        异步发送成功回调函数，也就是真正发送到kafka集群且成功才会执行。发送到缓冲区不会执行回调方法。</span></span><br><span class="line"><span class="string">        :param record_metadata:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;被发往的主题：&quot;</span>, record_metadata.topic)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;被发往的分区：&quot;</span>, record_metadata.partition)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;队列位置：&quot;</span>, record_metadata.offset)  <span class="comment"># 这个偏移量是相对偏移量，也就是相对起止位置，也就是队列偏移量。</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_onSendFailed</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发送失败&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sendMessage</span>(<span class="params">self, value=<span class="literal">None</span>, partition=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 发送的消息必须是序列化后的，或者是字节</span></span><br><span class="line">        <span class="comment"># message = json.dumps(msg, encoding=&#x27;utf-8&#x27;, ensure_ascii=False)</span></span><br><span class="line"> </span><br><span class="line">        kwargs = &#123;</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: value, <span class="comment"># value 必须必须为字节或者被序列化为字节，由于之前我们初始化时已经通过value_serializer来做了，所以我上面的语句就注释了</span></span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="literal">None</span>,  <span class="comment"># 与value对应的键，可选，也就是把一个键关联到这个消息上，KEY相同就会把消息发送到同一分区上，所以如果有这个要求就可以设置KEY，也需要序列化</span></span><br><span class="line">            <span class="string">&quot;partition&quot;</span>: partition <span class="comment"># 发送到哪个分区，整型。如果不指定将会自动分配。</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 异步发送，发送到缓冲区，同时注册两个回调函数，一个是发送成功的回调，一个是发送失败的回调。</span></span><br><span class="line">            <span class="comment"># send函数是有返回值的是RecordMetadata，也就是记录的元数据，包括主题、分区、偏移量</span></span><br><span class="line">            future = self._producer.send(self._topic, **kwargs).add_callback(self._onSendSucess).add_errback(self._onSendFailed)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;发送消息:&quot;</span>, value)</span><br><span class="line">            <span class="comment"># 注册回调也可以这样写，上面的写法就是为了简化</span></span><br><span class="line">            <span class="comment"># future.add_callback(self._onSendSucess)</span></span><br><span class="line">            <span class="comment"># future.add_errback(self._onSendFailed)</span></span><br><span class="line">        <span class="keyword">except</span> KafkaTimeoutError <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(err)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(err)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closeConnection</span>(<span class="params">self, timeout=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># 关闭生产者，可以指定超时时间，也就是等待关闭成功最多等待多久。</span></span><br><span class="line">        self._producer.close(timeout=timeout)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sendNow</span>(<span class="params">self, timeout=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># 调用flush()函数可以放所有在缓冲区的消息记录立即发送，即使ligner_ms值大于0.</span></span><br><span class="line">        <span class="comment"># 这时候后台发送消息线程就会开始立即发送消息并且阻塞在这里，等待消息发送成功，当然是否阻塞取决于acks的值。</span></span><br><span class="line">        <span class="comment"># 如果不调用flush函数，那么什么时候发送消息取决于ligner_ms或者batch任意一个条件满足就会发送。</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._producer.flush(timeout=timeout)</span><br><span class="line">        <span class="keyword">except</span> KafkaTimeoutError <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(err)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(err)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    p = Producer(KafkaServerList=[<span class="string">&quot;172.16.42.156:9092&quot;</span>], ClientId=<span class="string">&quot;Procucer01&quot;</span>, Topic=<span class="string">&quot;TESTTOPIC&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        closePrice = random.randint(<span class="number">1</span>, <span class="number">500</span>)</span><br><span class="line">        msg = &#123;</span><br><span class="line">            <span class="string">&quot;Publisher&quot;</span>: <span class="string">&quot;Procucer01&quot;</span>,</span><br><span class="line">            <span class="string">&quot;股票代码&quot;</span>: <span class="number">60000</span> + i,</span><br><span class="line">            <span class="string">&quot;昨日收盘价&quot;</span>: closePrice,</span><br><span class="line">            <span class="string">&quot;今日开盘价&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;今日收盘价&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        p.sendMessage(value=msg)</span><br><span class="line">    <span class="comment"># p.sendNow()</span></span><br><span class="line">    p.closeConnection()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p> python 发送kafka大体有三种方式 ,上面介绍的add_callback和add_errback是异步发送,最常用的一种发送方式了吧,另外还有两种方法,记一下吧.</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">发送并忘记</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>1 发送并忘记（不关注是否正常到达，不对返回结果做处理）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=[<span class="string">&#x27;ip:9092&#x27;</span>],</span><br><span class="line">                          key_serializer=<span class="keyword">lambda</span> k: pickle.dumps(k),</span><br><span class="line">                          value_serializer=<span class="keyword">lambda</span> v: pickle.dumps(v))</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------&#123;&#125;---------&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="comment"># 就是这里</span></span><br><span class="line">    future = producer.send(<span class="string">&#x27;test_topic&#x27;</span>, key=<span class="string">&#x27;num&#x27;</span>, value=i, partition=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将缓冲区的全部消息push到broker当中</span></span><br><span class="line">producer.flush()</span><br><span class="line">producer.close()</span><br><span class="line"></span><br><span class="line">end_time = time.time()</span><br><span class="line">time_counts = end_time - start_time  <span class="comment"># 顺便统计一下时间</span></span><br><span class="line"><span class="built_in">print</span>(time_counts)</span><br></pre></td></tr></table></figure><!-- endtab 同步发送 --><!-- tab --><p> 2 同步发送(通过get方法等待Kafka的响应，判断消息是否发送成功) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=[<span class="string">&#x27;ip:9092&#x27;</span>],</span><br><span class="line">                          key_serializer=<span class="keyword">lambda</span> k: pickle.dumps(k),</span><br><span class="line">                          value_serializer=<span class="keyword">lambda</span> v: pickle.dumps(v))</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;------&#123;&#125;---------&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">     future = producer.send(topic=<span class="string">&quot;test_topic&quot;</span>, key=<span class="string">&quot;num&quot;</span>, value=i)</span><br><span class="line">     <span class="comment"># 同步阻塞,通过调用get()方法进而保证一定程序是有序的.</span></span><br><span class="line">     <span class="keyword">try</span>:</span><br><span class="line">         record_metadata = future.get(timeout=<span class="number">10</span>)</span><br><span class="line">         <span class="comment"># print(record_metadata.topic)</span></span><br><span class="line">         <span class="comment"># print(record_metadata.partition)</span></span><br><span class="line">         <span class="comment"># print(record_metadata.offset)</span></span><br><span class="line">     <span class="keyword">except</span> kafka_errors <span class="keyword">as</span> e:</span><br><span class="line">         <span class="built_in">print</span>(<span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将缓冲区的全部消息push到broker当中</span></span><br><span class="line">producer.flush()</span><br><span class="line">producer.close()</span><br><span class="line"></span><br><span class="line">end_time = time.time()</span><br><span class="line">time_counts = end_time - start_time  <span class="comment"># 顺便统计一下时间</span></span><br><span class="line"><span class="built_in">print</span>(time_counts)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><ol><li><p>手动拉取消息</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, KafkaServerList=[<span class="string">&#x27;172.16.48.171:9092&#x27;</span>], GroupID=<span class="string">&#x27;TestGroup&#x27;</span>, ClientId=<span class="string">&quot;Test&quot;</span>, Topics=[<span class="string">&#x27;Test&#x27;</span>,]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        用于设置消费者配置信息，这些配置项可以从源码中找到，下面为必要参数。</span></span><br><span class="line"><span class="string">        :param KafkaServerList: kafka服务器IP:PORT 列表</span></span><br><span class="line"><span class="string">        :param GroupID: 消费者组ID</span></span><br><span class="line"><span class="string">        :param ClientId: 消费者名称</span></span><br><span class="line"><span class="string">        :param Topic: 主题</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化一个消费者实例，消费者不是线程安全的，所以建议一个线程实现一个消费者，而不是一个消费者让多个线程共享</span></span><br><span class="line"><span class="string">        下面这些是可选参数，可以在初始化KafkaConsumer实例的时候传递进去</span></span><br><span class="line"><span class="string">        enable_auto_commit 是否自动提交，默认是true</span></span><br><span class="line"><span class="string">        auto_commit_interval_ms 自动提交间隔毫秒数</span></span><br><span class="line"><span class="string">        auto_offset_reset=&quot;earliest&quot;  重置偏移量，earliest移到最早的可用消息，latest最新的消息，默认为latest</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._kwargs = &#123;</span><br><span class="line">            <span class="string">&quot;bootstrap_servers&quot;</span>: KafkaServerList,</span><br><span class="line">            <span class="string">&quot;client_id&quot;</span>: ClientId,</span><br><span class="line">            <span class="string">&quot;group_id&quot;</span>: GroupID,</span><br><span class="line">            <span class="string">&quot;enable_auto_commit&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&quot;auto_offset_reset&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">            <span class="string">&quot;key_deserializer&quot;</span>: <span class="keyword">lambda</span> m: json.loads(m.decode(<span class="string">&#x27;utf-8&#x27;</span>)),</span><br><span class="line">            <span class="string">&quot;value_deserializer&quot;</span>: <span class="keyword">lambda</span> m: json.loads(m.decode(<span class="string">&#x27;utf-8&#x27;</span>)),</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._consumer = KafkaConsumer(**self._kwargs)</span><br><span class="line">            self._consumer.subscribe(topics=(Topics))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Consumer init failed, %s&quot;</span> % err)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">consumeMsg</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = self._consumer.poll(timeout_ms=<span class="number">5</span>, max_records=<span class="number">100</span>)  <span class="comment"># 拉取消息，字典类型</span></span><br><span class="line">                <span class="keyword">if</span> data:</span><br><span class="line">                    <span class="keyword">for</span> key <span class="keyword">in</span> data:</span><br><span class="line">                        consumerrecord = data.get(key)[<span class="number">0</span>]   <span class="comment"># 返回的是ConsumerRecord对象，可以通过字典的形式获取内容。</span></span><br><span class="line">                        <span class="keyword">if</span> consumerrecord != <span class="literal">None</span>:</span><br><span class="line">                            <span class="comment"># 消息消费逻辑</span></span><br><span class="line">                            message = &#123;</span><br><span class="line">                                <span class="string">&quot;Topic&quot;</span>: consumerrecord.topic,</span><br><span class="line">                                <span class="string">&quot;Partition&quot;</span>: consumerrecord.partition,</span><br><span class="line">                                <span class="string">&quot;Offset&quot;</span>: consumerrecord.offset,</span><br><span class="line">                                <span class="string">&quot;Key&quot;</span>: consumerrecord.key,</span><br><span class="line">                                <span class="string">&quot;Value&quot;</span>: consumerrecord.value</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="built_in">print</span>(message)</span><br><span class="line">                            <span class="comment"># 消费逻辑执行完毕后在提交偏移量</span></span><br><span class="line">                            self._consumer.commit()</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;%s consumerrecord is None.&quot;</span> % key)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(err)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        c = Consumer(KafkaServerList=[<span class="string">&#x27;192.168.51.193:9092&#x27;</span>], Topics=[<span class="string">&#x27;EEE888&#x27;</span>])</span><br><span class="line">        c.consumeMsg()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(err)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></li><li><p>非手动拉取消息 </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, KafkaServerList=[<span class="string">&#x27;172.16.48.171:9092&#x27;</span>], GroupID=<span class="string">&#x27;TestGroup&#x27;</span>, ClientId=<span class="string">&quot;Test&quot;</span>, Topics=[<span class="string">&#x27;Test&#x27;</span>,]</span>):</span><br><span class="line">        self._kwargs = &#123;</span><br><span class="line">            <span class="string">&quot;bootstrap_servers&quot;</span>: KafkaServerList,</span><br><span class="line">            <span class="string">&quot;client_id&quot;</span>: ClientId,</span><br><span class="line">            <span class="string">&quot;group_id&quot;</span>: GroupID,</span><br><span class="line">            <span class="string">&quot;enable_auto_commit&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&quot;auto_offset_reset&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">            <span class="string">&quot;key_deserializer&quot;</span>: <span class="keyword">lambda</span> m: json.loads(m.decode(<span class="string">&#x27;utf-8&#x27;</span>)),</span><br><span class="line">            <span class="string">&quot;value_deserializer&quot;</span>: <span class="keyword">lambda</span> m: json.loads(m.decode(<span class="string">&#x27;utf-8&#x27;</span>)),</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._consumer = KafkaConsumer(**self._kwargs)</span><br><span class="line">            self._consumer.subscribe(topics=(Topics))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Consumer init failed, %s&quot;</span> % err)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">consumeMsg</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">for</span> consumerrecord <span class="keyword">in</span> self._consumer:</span><br><span class="line">                    <span class="keyword">if</span> consumerrecord:</span><br><span class="line">                        message = &#123;</span><br><span class="line">                                <span class="string">&quot;Topic&quot;</span>: consumerrecord.topic,</span><br><span class="line">                                <span class="string">&quot;Partition&quot;</span>: consumerrecord.partition,</span><br><span class="line">                                <span class="string">&quot;Offset&quot;</span>: consumerrecord.offset,</span><br><span class="line">                                <span class="string">&quot;Key&quot;</span>: consumerrecord.key,</span><br><span class="line">                                <span class="string">&quot;Value&quot;</span>: consumerrecord.value</span><br><span class="line">                                    &#125;</span><br><span class="line">                        <span class="built_in">print</span>(message)</span><br><span class="line">                        self._consumer.commit()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(err)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        c = Consumer(KafkaServerList=[<span class="string">&#x27;192.168.51.193:9092&#x27;</span>], Topics=[<span class="string">&#x27;EEE888&#x27;</span>])</span><br><span class="line">        c.consumeMsg()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(err)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Kafka </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/post/9daba997.html"/>
      <url>/post/9daba997.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">t1[<span class="number">0</span>]=<span class="string">&#x27;TOM&#x27;</span> <span class="comment"># 报错：TypeError</span></span><br><span class="line">t1.append(<span class="string">&#x27;lili&#x27;</span>) <span class="comment"># 报错：TypeError</span></span><br><span class="line"><span class="comment"># 元组内的元素无法修改，指的是元组内索引指向的内存地址不能被修改</span></span><br><span class="line">t1 = (<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">id</span>(t1[<span class="number">0</span>]),<span class="built_in">id</span>(t1[<span class="number">1</span>]),<span class="built_in">id</span>(t1[<span class="number">2</span>])</span><br><span class="line">(<span class="number">4327403152</span>, <span class="number">4327403072</span>, <span class="number">4327422472</span>)</span><br><span class="line">t1[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">111</span> <span class="comment"># 如果元组中存在可变类型，是可以修改，但是修改后的内存地址不变</span></span><br><span class="line">t1</span><br><span class="line">(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, [<span class="number">111</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">id</span>(t1[<span class="number">0</span>]),<span class="built_in">id</span>(t1[<span class="number">1</span>]),<span class="built_in">id</span>(t1[<span class="number">2</span>]) <span class="comment"># 查看id仍然不变</span></span><br><span class="line">(<span class="number">4327403152</span>, <span class="number">4327403072</span>, <span class="number">4327422472</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元类</title>
      <link href="/post/7c613e7d.html"/>
      <url>/post/7c613e7d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-元类介绍"><a href="#一-元类介绍" class="headerlink" title="一 元类介绍"></a>一 元类介绍</h1><p> 什么是元类呢？一切源自于一句话：python中一切皆为对象。 </p> <div class="note simple"><p>元类就是用来实例化产生类的类</p></div><div class="note simple"><p>关系：元类—实例化—-&gt;类（People）—实例化—-&gt;对象（obj）</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s:%s&#x27;</span> %(self.name,self.name))</span><br></pre></td></tr></table></figure><p> 如果说类也是对象,那么People&#x3D;type(……) ,type是内置的元类.我们用class关键字定义的所有的类以及内置的类都是由元类type实例化产生的</p><h1 id="二-class机制分析"><a href="#二-class机制分析" class="headerlink" title="二 class机制分析"></a>二 class机制分析</h1><details class="folding-tag" green><summary> exec用法 </summary>              <div class='content'>              <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exec：三个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数一：包含一系列python代码的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数二：全局作用域（字典形式），如果不指定，默认为globals()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数三：局部作用域（字典形式），如果不指定，默认为locals()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以把exec命令的执行当成是一个函数的执行，会将执行期间产生的名字存放于局部名称空间中</span></span><br><span class="line">g=&#123;</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">l=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">global x,z</span></span><br><span class="line"><span class="string">x=100</span></span><br><span class="line"><span class="string">z=200</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">m=300</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>,g,l)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(g) <span class="comment">#&#123;&#x27;x&#x27;: 100, &#x27;y&#x27;: 2,&#x27;z&#x27;:200,......&#125;</span></span><br><span class="line"><span class="built_in">print</span>(l) <span class="comment">#&#123;&#x27;m&#x27;: 300&#125;</span></span><br></pre></td></tr></table></figure>              </div>            </details><p>class关键字在帮我们创建类时，必然帮我们调用了元类StanfordTeacher&#x3D;type(…)，那调用type时传入的参数是什么呢？必然是类的关键组成部分，一个类有三大组成部分，分别是</p><ul><li><p>类名class_name&#x3D;’People’</p></li><li><p>基类们class_bases&#x3D;(object,)</p></li><li><p>类的名称空间class_dic，类的名称空间是执行类体代码而得到的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class_dic=&#123;&#125;</span><br><span class="line">class_body=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def __init__(self,name,age):</span></span><br><span class="line"><span class="string">    self.name=name</span></span><br><span class="line"><span class="string">    self.age=age</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">def say(self):</span></span><br><span class="line"><span class="string">    print(&#x27;%s:%s&#x27; %(self.name,self.name))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">exec</span>(class_body,&#123;&#125;,class_dic)</span><br><span class="line"><span class="built_in">print</span>(class_dic)</span><br></pre></td></tr></table></figure></li><li><p>调用type时会依次传入以上三个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People=<span class="built_in">type</span>(class_name,class_bases,class_dic)</span><br></pre></td></tr></table></figure></li></ul><h1 id="三-自定义元类来控制类的产生"><a href="#三-自定义元类来控制类的产生" class="headerlink" title="三 自定义元类来控制类的产生"></a>三 自定义元类来控制类的产生</h1><p>先定义一个自己的元类,并且该类必须type元类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>): <span class="comment"># 只有继承了type类的类才是元类</span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">#            空对象,&quot;People&quot;,(),&#123;...&#125;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x,y,z</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run22222222222....&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="comment"># print(x)</span></span><br><span class="line">        <span class="comment"># print(y)</span></span><br><span class="line">        <span class="comment"># print(z)</span></span><br><span class="line">        <span class="comment"># print(y)</span></span><br><span class="line">        <span class="comment"># if not x.istitle():  # 可以写自己的判断逻辑</span></span><br><span class="line">        <span class="comment">#     raise NameError(&#x27;类名的首字母必须大写啊！！！&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#          当前所在的类，调用类时所传入的参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 造Mymeta的对象</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run1111111111.....&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(cls,args,kwargs)</span></span><br><span class="line">        <span class="comment"># return super().__new__(cls,*args, **kwargs)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls,*args, **kwargs)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">       <span class="comment"># 1、Mymeta.__call__函数内会先调用People内的__new__</span></span><br><span class="line">       people_obj=self.__new__(self)</span><br><span class="line">       <span class="comment"># 2、Mymeta.__call__函数内会调用People内的__init__</span></span><br><span class="line">       self.__init__(people_obj,*args, **kwargs)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># print(&#x27;people对象的属性：&#x27;,people_obj.__dict__)</span></span><br><span class="line">       people_obj.__dict__[<span class="string">&#x27;xxxxx&#x27;</span>]=<span class="number">11111</span></span><br><span class="line">       <span class="comment"># 3、Mymeta.__call__函数内会返回一个初始化好的对象</span></span><br><span class="line">       <span class="keyword">return</span> people_obj</span><br></pre></td></tr></table></figure><p>类的产生,People&#x3D;Mymeta(“People”,(object,),{…}),调用Mymeta(调用Mymeta就是调用type.<strong>call</strong>)发生三件事:</p><ul><li>type.<strong>call__函数内会先调用Mymeta内的__new</strong></li><li>type.<strong>call__函数内会调用Mymeta内的__init</strong></li><li>type.__call__函数内会返回一个初始化好的对象</li></ul><p>people类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(metaclass=Mymeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s:%s&#x27;</span> %(self.name,self.name))</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 产生真正的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br></pre></td></tr></table></figure><p>类的调用,obj&#x3D;People(‘lili’,18) &#x3D;》Mymeta.<strong>call</strong>&#x3D;》干了3件事</p><ul><li>Mymeta.<strong>call__函数内会先调用People内的__new</strong></li><li>Mymeta.<strong>call__函数内会调用People内的__init</strong></li><li>Mymeta.__call__函数内会返回一个初始化好的对象</li></ul><h1 id="四-元类下的属性查找"><a href="#四-元类下的属性查找" class="headerlink" title="四 元类下的属性查找"></a>四 元类下的属性查找</h1><p> 在学习完元类后，其实我们用class自定义的类也全都是对象（包括object类本身也是元类type的 一个实例，可以用type(object)查看），我们学习过继承的实现原理，如果把类当成对象去看，将下述继承应该说成是：对象StanfordTeacher继承对象Foo，对象Foo继承对象Bar，对象Bar继承对象object </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>): <span class="comment">#只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span></span><br><span class="line">    n=<span class="number">444</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment">#self=&lt;class &#x27;__main__.StanfordTeacher&#x27;&gt;</span></span><br><span class="line">        obj=self.__new__(self)</span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    n=<span class="number">333</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">Bar</span>):</span><br><span class="line">    n=<span class="number">222</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StanfordTeacher</span>(Foo,metaclass=Mymeta):</span><br><span class="line">    n=<span class="number">111</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;Stanford&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s says welcome to the Stanford to learn Python&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(StanfordTeacher.n) <span class="comment">#自下而上依次注释各个类中的n=xxx，然后重新运行程序，发现n的查找顺序为StanfordTeacher-&gt;Foo-&gt;Bar-&gt;object-&gt;Mymeta-&gt;type</span></span><br></pre></td></tr></table></figure><p>查找顺序：</p><ul><li>先对象层：StanfordTeacher-&gt;Foo-&gt;Bar-&gt;object</li><li>然后元类层：Mymeta-&gt;type</li></ul><p> 依据上述总结，我们来分析下元类Mymeta中__call__里的self.__new__的查找 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>): </span><br><span class="line">    n=<span class="number">444</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment">#self=&lt;class &#x27;__main__.StanfordTeacher&#x27;&gt;</span></span><br><span class="line">        obj=self.__new__(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__new__ <span class="keyword">is</span> <span class="built_in">object</span>.__new__) <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    n=<span class="number">333</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __new__(cls, *args, **kwargs):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;Bar.__new__&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">Bar</span>):</span><br><span class="line">    n=<span class="number">222</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __new__(cls, *args, **kwargs):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;Foo.__new__&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StanfordTeacher</span>(Foo,metaclass=Mymeta):</span><br><span class="line">    n=<span class="number">111</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;Stanford&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s says welcome to the Stanford to learn Python&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __new__(cls, *args, **kwargs):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;StanfordTeacher.__new__&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StanfordTeacher(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>) <span class="comment">#触发StanfordTeacher的类中的__call__方法的执行，进而执行self.__new__开始查找</span></span><br></pre></td></tr></table></figure><p> 总结，</p><ul><li>Mymeta下的__call__里的self.<strong>new__在StanfordTeacher、Foo、Bar里都没有找到__new__的情况下，会去找object里的__new__，而object下默认就有一个__new__，所以即便是之前的类均未实现__new</strong>,也一定会在object中找到一个，根本不会、也根本没必要再去找元类Mymeta-&gt;type中查找__new__ </li><li>我们在元类的__call__中也可以用object.<strong>new</strong>(self)去造对象 </li><li>但我们还是推荐在__call__中使用self.<strong>new</strong>(self)去创造空对象，因为这种方式会检索三个类StanfordTeacher-&gt;Foo-&gt;Bar,而object.__new__则是直接跨过了他们三个</li></ul><p>最后说明一点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>): <span class="comment">#只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span></span><br><span class="line">    n=<span class="number">444</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        obj=<span class="built_in">type</span>.__new__(cls,*args,**kwargs) <span class="comment"># 必须按照这种传值方式</span></span><br><span class="line">        <span class="built_in">print</span>(obj.__dict__)</span><br><span class="line">        <span class="comment"># return obj # 只有在返回值是type的对象时，才会触发下面的__init__</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,class_name,class_bases,class_dic</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run。。。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StanfordTeacher</span>(<span class="built_in">object</span>,metaclass=Mymeta): <span class="comment">#StanfordTeacher=Mymeta(&#x27;StanfordTeacher&#x27;,(object),&#123;...&#125;)</span></span><br><span class="line">    n=<span class="number">111</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;Stanford&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s says welcome to the Stanford to learn Python&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Mymeta)) <span class="comment">#&lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 产生类StanfordTeacher的过程就是在调用Mymeta，而Mymeta也是type类的一个对象，那么Mymeta之所以可以调用，一定是在元类type中有一个__call__方法</span></span><br><span class="line"><span class="comment"># 该方法中同样需要做至少三件事：</span></span><br><span class="line"><span class="comment"># class type:</span></span><br><span class="line"><span class="comment">#     def __call__(self, *args, **kwargs): #self=&lt;class &#x27;__main__.Mymeta&#x27;&gt;</span></span><br><span class="line"><span class="comment">#         obj=self.__new__(self,*args,**kwargs) # 产生Mymeta的一个对象</span></span><br><span class="line"><span class="comment">#         self.__init__(obj,*args,**kwargs) </span></span><br><span class="line"><span class="comment">#         return obj</span></span><br></pre></td></tr></table></figure><h1 id="五-基于元类实现单例模式"><a href="#五-基于元类实现单例模式" class="headerlink" title="五 基于元类实现单例模式"></a>五 基于元类实现单例模式</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单例：即单个实例，指的是同一个类实例化多次的结果指向同一个对象，用于节省内存空间</span></span><br><span class="line"><span class="comment"># 如果我们从配置文件中读取配置来进行实例化，在配置相同的情况下，就没必要重复产生对象浪费内存了</span></span><br><span class="line"><span class="comment">#settings.py文件内容如下</span></span><br><span class="line">HOST=<span class="string">&#x27;1.1.1.1&#x27;</span></span><br><span class="line">PORT=<span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方式一:定义一个类方法实现单例模式</span></span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mysql</span>:</span><br><span class="line">    __instance=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,host,port</span>):</span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">            cls.__instance=cls(settings.HOST,settings.PORT)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">obj1=Mysql(<span class="string">&#x27;1.1.1.2&#x27;</span>,<span class="number">3306</span>)</span><br><span class="line">obj2=Mysql(<span class="string">&#x27;1.1.1.3&#x27;</span>,<span class="number">3307</span>)</span><br><span class="line"><span class="built_in">print</span>(obj1 <span class="keyword">is</span> obj2) <span class="comment">#False</span></span><br><span class="line"></span><br><span class="line">obj3=Mysql.singleton()</span><br><span class="line">obj4=Mysql.singleton()</span><br><span class="line"><span class="built_in">print</span>(obj3 <span class="keyword">is</span> obj4) <span class="comment">#True</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方式二：定制元类实现单例模式</span></span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,bases,dic</span>): <span class="comment">#定义类Mysql时就触发</span></span><br><span class="line">        <span class="comment"># 事先先从配置文件中取配置来造一个Mysql的实例出来</span></span><br><span class="line">        self.__instance = <span class="built_in">object</span>.__new__(self)  <span class="comment"># 产生对象</span></span><br><span class="line">        self.__init__(self.__instance, settings.HOST, settings.PORT)  <span class="comment"># 初始化对象</span></span><br><span class="line">        <span class="comment"># 上述两步可以合成下面一步</span></span><br><span class="line">        <span class="comment"># self.__instance=super().__call__(*args,**kwargs)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name,bases,dic)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment">#Mysql(...)时触发</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">or</span> kwargs: <span class="comment"># args或kwargs内有值</span></span><br><span class="line">            obj=<span class="built_in">object</span>.__new__(self)</span><br><span class="line">            self.__init__(obj,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mysql</span>(metaclass=Mymeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,host,port</span>):</span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"></span><br><span class="line">obj1=Mysql() <span class="comment"># 没有传值则默认从配置文件中读配置来实例化，所有的实例应该指向一个内存地址</span></span><br><span class="line">obj2=Mysql()</span><br><span class="line">obj3=Mysql()</span><br><span class="line"><span class="built_in">print</span>(obj1 <span class="keyword">is</span> obj2 <span class="keyword">is</span> obj3)</span><br><span class="line">obj4=Mysql(<span class="string">&#x27;1.1.1.4&#x27;</span>,<span class="number">3307</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方式三:定义一个装饰器实现单例模式</span></span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>): <span class="comment">#cls=Mysql</span></span><br><span class="line">    _instance=cls(settings.HOST,settings.PORT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">or</span> kwargs:</span><br><span class="line">            obj=cls(*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        <span class="keyword">return</span> _instance</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton </span><span class="comment"># Mysql=singleton(Mysql)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mysql</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,host,port</span>):</span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"></span><br><span class="line">obj1=Mysql()</span><br><span class="line">obj2=Mysql()</span><br><span class="line">obj3=Mysql()</span><br><span class="line"><span class="built_in">print</span>(obj1 <span class="keyword">is</span> obj2 <span class="keyword">is</span> obj3) <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">obj4=Mysql(<span class="string">&#x27;1.1.1.3&#x27;</span>,<span class="number">3307</span>)</span><br><span class="line">obj5=Mysql(<span class="string">&#x27;1.1.1.4&#x27;</span>,<span class="number">3308</span>)</span><br><span class="line"><span class="built_in">print</span>(obj3 <span class="keyword">is</span> obj4) <span class="comment">#False</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成器</title>
      <link href="/post/2178aef8.html"/>
      <url>/post/2178aef8.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-生成器与yield"><a href="#1-生成器与yield" class="headerlink" title="1.生成器与yield"></a>1.生成器与yield</h1><ul><li>若函数体包含yield关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象</li></ul>  <div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>注意的是,函数体内有yield关键字不能说该函数就是生成器,好好体会上面这句话</p></div>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">start,stop,step=<span class="number">1</span></span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> start &lt; stop:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> start</span><br><span class="line"><span class="meta">... </span>        start+=step</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;end...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=my_range(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> my_range at <span class="number">0x104105678</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>生成器内置有__iter__和__next__方法，所以生成器本身就是一个特殊的迭代器 </p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__iter__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__iter__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__next__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__next__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行直到遇到yield则停止,将yield后的值返回，并在当前位置挂起函数</span></span><br><span class="line">start...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 再次调用next(g)，函数从上次暂停的位置继续执行，直到重新遇到yield...</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 周而复始...</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行没有遇到yield则无值返回，即取值完毕抛出异常结束迭代</span></span><br><span class="line">end...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><h1 id="2-yield表达式的应用"><a href="#2-yield表达式的应用" class="headerlink" title="2.yield表达式的应用"></a>2.yield表达式的应用</h1><h2 id="1-在函数内可以采用表达式形式的yield"><a href="#1-在函数内可以采用表达式形式的yield" class="headerlink" title="1.在函数内可以采用表达式形式的yield"></a>1.在函数内可以采用表达式形式的yield</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">eater</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        food=<span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> %food)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​     可以拿到函数的生成器对象持续为函数体send值，如下 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=eater() <span class="comment"># 得到生成器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> eater at <span class="number">0x101b6e2b0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(e) <span class="comment"># 需要事先”初始化”一次，让函数挂起在food=yield，等待调用g.send()方法为其传值</span></span><br><span class="line">Ready to eat</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="string">&#x27;包子&#x27;</span>)</span><br><span class="line">get the food: 包子, <span class="keyword">and</span> start to eat</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="string">&#x27;鸡腿&#x27;</span>)</span><br><span class="line">get the food: 鸡腿, <span class="keyword">and</span> start to eat</span><br></pre></td></tr></table></figure><pre><code>  针对表达式形式的yield，生成器对象必须事先被初始化一次，让函数挂起在food=yield的位置，等待调用g.send()方法为函数体传值g.send(None)等同于next(g)。 </code></pre><h2 id="2-编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作"><a href="#2-编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作" class="headerlink" title="2.编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作"></a>2.编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        g=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@init</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eater</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food=<span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> %food)</span><br></pre></td></tr></table></figure><h2 id="3-yield返回值"><a href="#3-yield返回值" class="headerlink" title="3.yield返回值"></a>3.yield返回值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">eater</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    food_list=[]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        food=<span class="keyword">yield</span> food_list</span><br><span class="line"><span class="meta">... </span>        food_list.append(food)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e=eater()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(e)</span><br><span class="line">Ready to eat</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸羊羔&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸熊掌&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸鹿尾儿&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>, <span class="string">&#x27;蒸鹿尾儿&#x27;</span>]</span><br></pre></td></tr></table></figure><h1 id="3-其他生成式"><a href="#3-其他生成式" class="headerlink" title="3.其他生成式"></a>3.其他生成式</h1><h2 id="3-1-三元表达式"><a href="#3-1-三元表达式" class="headerlink" title="3.1 三元表达式"></a>3.1 三元表达式</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max2</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">res = max2(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># res = 条件成立时返回的值 if 条件 else 条件不成立时返回的值</span></span><br><span class="line">res = x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y <span class="comment"># 三元表达式</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="3-2-列表生成式"><a href="#3-2-列表生成式" class="headerlink" title="3.2 列表生成式"></a>3.2 列表生成式</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[expression <span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1 <span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2 <span class="keyword">if</span> condition2</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN <span class="keyword">if</span> conditionN</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#类似于</span></span><br><span class="line">res=[]</span><br><span class="line"><span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1:</span><br><span class="line">    <span class="keyword">if</span> condition1:</span><br><span class="line">        <span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2:</span><br><span class="line">            <span class="keyword">if</span> condition2</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN:</span><br><span class="line">                    <span class="keyword">if</span> conditionN:</span><br><span class="line">                        res.append(expression)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egg_list=[ i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="3-3-生成器表达式"><a href="#3-3-生成器表达式" class="headerlink" title="3.3 生成器表达式"></a>3.3 生成器表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=(x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x101be0ba0</span>&gt;</span><br></pre></td></tr></table></figure><p>​      <div class="note icon simple"><i class="note-icon fab fa-cc-visa"></i><p>对比列表生成式，生成器表达式的优点自然是节省内存（一次只产生一个值在内存中）</p></div></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p> 如果我们要读取一个大文件的字节数，应该基于生成器表达式的方式完成 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    nums=(<span class="built_in">len</span>(line) <span class="keyword">for</span> line <span class="keyword">in</span> f)</span><br><span class="line">    total_size=<span class="built_in">sum</span>(nums) <span class="comment"># 依次执行next(nums)，然后累加到一起得到结果=</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/post/2cf69f40.html"/>
      <url>/post/2cf69f40.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h1> <div class="note simple"><p>提示块标签迭代器即用来迭代取值的工具，而迭代是重复反馈过程的活动，其目的通常是为了逼近所需的目标或结果，每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值,单纯的重复并不是迭代 </p></div><h2 id="1-1-可迭代对象"><a href="#1-1-可迭代对象" class="headerlink" title="1.1 可迭代对象"></a>1.1 可迭代对象</h2><p>通过索引的方式进行迭代取值，实现简单，但仅适用于序列类型：字符串，列表，元组。对于没有索引的字典、集合等非序列类型，必须找到一种不依赖索引来进行迭代取值的方式，这就用到了迭代器。</p><p>要想了解迭代器为何物，必须事先搞清楚一个很重要的概念：可迭代对象(Iterable)。从语法形式上讲，内置有__iter__方法的对象都是可迭代对象，字符串、列表、元组、字典、集合、打开的文件都是可迭代对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;egon&#x27;</span>&#125;.__iter__</span><br><span class="line">&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;.__iter__</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="1-2-迭代器对象"><a href="#1-2-迭代器对象" class="headerlink" title="1.2 迭代器对象"></a>1.2 迭代器对象</h2><div class="note modern"><p>调用obj.<strong>iter</strong>()方法返回的结果就是一个迭代器对象(Iterator)。迭代器对象是内置有<strong>iter</strong>和<strong>next</strong>方法的对象，打开的文件本身就是一个迭代器对象，执行迭代器对象.<strong>iter</strong>()方法得到的仍然是迭代器本身，而执行迭代器.<strong>next</strong>()方法就会计算出迭代器中的下一个值。 迭代器是Python提供的一种统一的、不依赖于索引的迭代取值方式，只要存在多个“值”，无论序列类型还是非序列类型都可以按照迭代器的方式取值</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment"># 可迭代对象s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i=<span class="built_in">iter</span>(s)  <span class="comment"># 本质就是在调用s.__iter__(),返回s的迭代器对象i，</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i) <span class="comment"># 本质就是在调用i.__next__()</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)  <span class="comment">#抛出StopIteration的异常，代表无值可取，迭代结束</span></span><br></pre></td></tr></table></figure><h1 id="for循环原理"><a href="#for循环原理" class="headerlink" title="for循环原理"></a>for循环原理</h1><div class='wow animate__flip' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' ><div class="note green icon modern"><i class="note-icon fas fa-fan"></i><p> 有了迭代器后，我们便可以不依赖索引迭代取值了，使用while循环的实现方式如下 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line">i=<span class="built_in">iter</span>(goods) <span class="comment">#每次都需要重新获取一个迭代器对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(i))</span><br><span class="line">    <span class="keyword">except</span> StopIteration: <span class="comment">#捕捉异常终止循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div></div> <div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon modern"><i class="note-icon fas fa-bullhorn"></i><p>for循环又称为迭代循环，in后可以跟任意可迭代对象，上述while循环可以简写为 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> goods:   </span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></div></div><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal"> for 循环在工作时，首先会调用可迭代对象goods内置的**iter**方法拿到一个迭代器对象，然后再调用该迭代器对象的**next**方法将取到的值赋给item,执行循环体完成一次循环，周而复始，直到捕捉StopIteration异常，结束迭代。 </p></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器</title>
      <link href="/post/da520e93.html"/>
      <url>/post/da520e93.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>装饰器的作用</p><p class='p cyan'>软件的设计应该遵循开放封闭原则，即对扩展是开放的，而对修改是封闭的。对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着对象一旦设计完成，就可以独立完成其工作，而不要对其进行修改。</p><p class='p blue'>软件包含的所有功能的源代码以及调用方式，都应该避免修改，否则一旦改错，则极有可能产生连锁反应，最终导致程序崩溃，而对于上线后的软件，新需求或者变化又层出不穷，我们必须为程序提供扩展的可能性，这就用到了装饰器。</p></li></ul><div class="note simple"><p>函数装饰器分为：无参装饰器和有参装饰两种，二者的实现原理一样，都是’函数嵌套+闭包+函数对象’的组合使用的产物。 </p></div><h1 id="无参装饰器"><a href="#无参装饰器" class="headerlink" title="无参装饰器"></a>无参装饰器</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p> 实现一个无参装饰器timer，可以在不修改被装饰对象index源代码和调用方式的前提下为其加上新功能。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个timer装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通函数index,home</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the index page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the home page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p> 此时我们就可以用timer来装饰带参数或不带参数的函数了 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer </span><span class="comment"># index=timer(index)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the index page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p> 如果我们有多个装饰器，可以叠加多个 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@deco3</span></span><br><span class="line"><span class="meta">@deco2</span></span><br><span class="line"><span class="meta">@deco1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p> 叠加多个装饰器无特殊之处，上述代码语义如下 </p><div class="note simple"><p>index&#x3D;deco3(deco2(deco1(index)))</p></div><div class="tip warning faa-horizontal animated"><p>注意的是,多个装饰器装饰的顺序从下倒上,执行顺序从上到下</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="有参装饰器"><a href="#有参装饰器" class="headerlink" title="有参装饰器"></a>有参装饰器</h1><ul><li>如果我们想提供多种不同的认证方式以供选择 ,如下 函数wrapper需要一个driver参数，而函数deco与wrapper的参数都有其特定的功能，不能用来接受其他类别的参数，可以在deco的外部再包一层函数auth，用来专门接受额外的参数，这样便保证了在auth函数内无论多少层都可以引用到</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">auth</span>(<span class="params">driver</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> driver == <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">                编写基于文件的认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">            <span class="keyword">elif</span> driver == <span class="string">&#x27;mysql&#x27;</span>:</span><br><span class="line">                编写基于mysql认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> deco</span><br></pre></td></tr></table></figure><ul><li>此时我们就实现了一个有参装饰器，使用方式如下</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先调用auth(driver=&#x27;file&#x27;)，得到@deco，deco是一个闭包函数，</span></span><br><span class="line"><span class="comment">#包含了对外部作用域名字driver的引用，@deco的语法意义与无参装饰器一样</span></span><br><span class="line"><span class="meta">@auth(<span class="params">driver=<span class="string">&#x27;file&#x27;</span></span>) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():     </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@auth(<span class="params">driver=<span class="string">&#x27;mysql&#x27;</span></span>) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    <span class="keyword">pass</span>  </span><br></pre></td></tr></table></figure><ul><li><p>此外,因为index已经不是原来那个index了,而是wrapper函数.如果我们想要被装饰的index函数任然看起来跟原始的index函数看起来一摸一样,那么我们可以简单的包装”wraps”一下.</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p> 在被装饰之后home&#x3D;wrapper,查看home.<strong>name</strong>也可以发现home的函数名确实是wrapper，想要保留原函数的文档和函数名属性，需要修正装饰器 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    wrapper.__doc__=func.__doc__</span><br><span class="line">    wrapper.__name__=func.__name__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p> 按照上述方式来实现保留原函数属性过于麻烦，functools模块下提供一个装饰器wraps专门用来帮我们实现这件事，用法如下 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变与不可变类型</title>
      <link href="/post/4e9b1069.html"/>
      <url>/post/4e9b1069.html</url>
      
        <content type="html"><![CDATA[<h1 id="可变数据类型"><a href="#可变数据类型" class="headerlink" title="可变数据类型"></a><strong>可变数据类型</strong></h1><p>值发生改变时，内存地址不变，即id不变，证明在改变原值</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;egon&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(list1)</span><br><span class="line"><span class="number">486316639176</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1[<span class="number">2</span>] = <span class="string">&#x27;kevin&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(list1)</span><br><span class="line"><span class="number">486316639176</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1.append(<span class="string">&#x27;lili&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(list1)</span><br><span class="line"><span class="number">486316639176</span></span><br><span class="line"><span class="comment"># 对列表的值进行操作时，值改变但内存地址不变，所以列表是可变数据类型</span></span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/dbt2eRVYfCUKk85.png" alt="1663491472029"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/S8n2Q4sWRefxHwu.png" alt="1663491493828"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/qidjSl9cwETQ1Lf.png" alt="1663491545185"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(dic)</span><br><span class="line"><span class="number">4327423112</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">&#x27;age&#x27;</span>]=<span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;egon&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(dic)</span><br><span class="line"><span class="number">4327423112</span></span><br><span class="line"><span class="comment"># 对字典进行操作时，值改变的情况下，字典的id也是不变，即字典也是可变数据类型</span></span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/i8EDMhZqmO6YPUI.png" alt="1663491806354"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/4ZBTUOzo7tfxRhs.png" alt="1663491828358"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="不可变类型"><a href="#不可变类型" class="headerlink" title="不可变类型"></a><strong>不可变类型</strong></h1><p>值发生改变时，内存地址也发生改变，即id也变，证明是没有在改变原值，是产生了新的值</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a><strong>数字类型</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">1830448896</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">1830448928</span></span><br><span class="line"><span class="comment"># 内存地址改变了，说明整型是不可变数据类型，浮点型也一样</span></span><br></pre></td></tr></table></figure><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/zs3tOI2AmiQghBa.png" alt="1663490793653"></p>              </div>            </details><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&quot;Jy&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">938809263920</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&quot;Ricky&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">938809264088</span></span><br><span class="line"><span class="comment"># 内存地址改变了，说明字符串是不可变数据类型</span></span><br></pre></td></tr></table></figure><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/Vc3x2pIwTYtnf5B.png" alt="1663491001856"></p>              </div>            </details><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">0</span>]=<span class="string">&#x27;TOM&#x27;</span> <span class="comment"># 报错：TypeError</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1.append(<span class="string">&#x27;lili&#x27;</span>) <span class="comment"># 报错：TypeError</span></span><br><span class="line"><span class="comment"># 元组内的元素无法修改，指的是元组内索引指向的内存地址不能被修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t1[<span class="number">0</span>]),<span class="built_in">id</span>(t1[<span class="number">1</span>]),<span class="built_in">id</span>(t1[<span class="number">2</span>])</span><br><span class="line">(<span class="number">4327403152</span>, <span class="number">4327403072</span>, <span class="number">4327422472</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">111</span> <span class="comment"># 如果元组中存在可变类型，是可以修改，但是修改后的内存地址不变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1</span><br><span class="line">(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, [<span class="number">111</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t1[<span class="number">0</span>]),<span class="built_in">id</span>(t1[<span class="number">1</span>]),<span class="built_in">id</span>(t1[<span class="number">2</span>]) <span class="comment"># 查看id仍然不变</span></span><br><span class="line">(<span class="number">4327403152</span>, <span class="number">4327403072</span>, <span class="number">4327422472</span>)</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/GsNM3efjgqOxz8V.png" alt="1663491674673"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/NRWbp6SrDK4ze5F.png" alt="1663491711256"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数据类型总结"><a href="#数据类型总结" class="headerlink" title="数据类型总结"></a>数据类型总结</h1><ol><li><div class='wow animate__flip' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' >   <div class="note green icon modern"><i class="note-icon fas fa-fan"></i><p>按存值个数区分</p></div>   </div><p>只能存一个值: 字符串,数字</p><p>可以存多个值(容器类型):列表,元祖,字典</p><p>​</p></li><li><div class='wow animate__flipInX' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' >   <div class="note green icon modern"><i class="note-icon fas fa-fan"></i><p>按访问方式区分</p></div>   </div><p>直接访问: 数字</p><p>顺序访问: 列表,元祖,字符串</p><p>key访问: 字典</p></li><li><div class='wow animate__flipInY' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' >   <div class="note green icon modern"><i class="note-icon fas fa-fan"></i><p>按可变与不可变区分</p></div>   </div><p> 可变: 列表,字典</p><p>不可变: 字符串,元祖,数字</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3</title>
      <link href="/post/3a42db2d.html"/>
      <url>/post/3a42db2d.html</url>
      
        <content type="html"><![CDATA[<p>之前写了一篇关于 Vue2 的后台管理系统模板的推荐，详情请见 Vue后台管理系统模板推荐。</p><p>Vue3 在今年2月份已成为新的默认版本，本文收集了一些 Vue3 的后台管理系统模板，分享给在座的仌（打工人乃人上人👣）。</p><p>还是老规矩，按照 Github 星标数量来依次介绍。</p><p>个人较推荐 vue-vben-admin、vue-pure-admin、naive-ui-admin、vue3-composition-admin、vue-next-admin。意见仅供参考，具体可根据团队审美，业务需求选择一款更契合的后台管理系统模板。</p><p>gin-vue-admin (14.2k)<br>如果后台选择的是go语言，可以考虑这一款。</p><p>gin-vue-admin（github上的标星数为14.2k）基于 vite + vue3 + gin 搭建的开发基础平台（支持TS，JS 混用），集成 jwt鉴权，权限管理，动态路由，显隐可控组件，分页封装，多点登录拦截，资源权限，上传下载，代码生成器，表单生成器等开发必备功能。</p><p>相关地址<br>文档地址：gin-vue-admin Documentation<br>仓库地址：<a href="https://github.com/flipped-aurora/gin-vue-admin">https://github.com/flipped-aurora/gin-vue-admin</a><br>预览地址：<a href="http://demo.gin-vue-admin.com/">http://demo.gin-vue-admin.com</a><br>技术选型<br>前端：用基于 Vue 的 Element 构建基础页面。<br>后端：用 Gin 快速搭建基础 restful风格API，Gin 是一个go语言编写的Web框架。<br>数据库：采用MySql&gt;5.7版本，数据库引擎 innoDB，使用 gorm 实现对数据库的基本操作，已添加对sqlite数据库的支持。<br>缓存：使用Redis实现记录当前活跃用户的jwt令牌并实现多点登录限制。<br>API文档：使用Swagger构建自动化文档。<br>配置文件：使用 fsnotify 和 viper 实现yaml格式的配置文件。<br>日志：使用 zap 实现日志记录。<br>主要功能<br>权限管理：基于jwt和casbin实现的权限管理<br>用户管理：系统管理员分配用户角色和角色权限。<br>角色管理：创建权限控制的主要对象，可以给角色分配不同api权限和菜单权限。<br>菜单管理：实现用户动态菜单配置，实现不同角色不同菜单。<br>api管理：不同用户可调用的api接口的权限不同。<br>富文本编辑器：MarkDown编辑器功能嵌入。<br>restful示例：可以参考用户管理模块中的示例API。<br>多点登录限制：需要在config.yaml中把system中的useMultipoint修改为true(需要自行配置Redis和Config中的Redis参数，测试阶段，有bug请及时反馈)。<br>表单生成器：表单生成器借助 @form-generator。<br>代码生成器：后台基础逻辑以及简单curd的代码生成器等。<br>预览效果</p><p>vue-vben-admin (13.5k)<br>Vue-Vben-Admin（github上的标星数为13.5k）是一个基于 Vue3.0、Vite、 Ant-Design-Vue、TypeScript 的后台解决方案，目标是为开发中大型项目提供开箱即用的解决方案。包括二次封装组件、utils、hooks、动态菜单、权限校验、按钮级别权限控制等功能。项目使用前端较新的技术栈，可以作为项目的启动模版，以帮助你快速搭建企业级中后台产品原型。</p><p>相关地址<br>文档地址：Vben Admin Documentation<br>仓库地址：完整版、简化版<br>预览地址：完整版、简化版<br>特点<br>最新技术栈：使用 Vue3&#x2F;vite2 等前端前沿技术开发<br>TypeScript: 应用程序级 JavaScript 的语言<br>主题：可配置的主题<br>国际化：内置完善的国际化方案<br>Mock 数据 内置 Mock 数据方案<br>权限 内置完善的动态路由权限生成方案<br>组件 二次封装了多个常用的组件<br>预览效果</p>]]></content>
      
      
      <categories>
          
          <category> 前段Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/16107.html"/>
      <url>/post/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
