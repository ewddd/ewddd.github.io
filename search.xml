<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试</title>
      <link href="/post/9daba997.html"/>
      <url>/post/9daba997.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">t1[<span class="number">0</span>]=<span class="string">&#x27;TOM&#x27;</span> <span class="comment"># 报错：TypeError</span></span><br><span class="line">t1.append(<span class="string">&#x27;lili&#x27;</span>) <span class="comment"># 报错：TypeError</span></span><br><span class="line"><span class="comment"># 元组内的元素无法修改，指的是元组内索引指向的内存地址不能被修改</span></span><br><span class="line">t1 = (<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">id</span>(t1[<span class="number">0</span>]),<span class="built_in">id</span>(t1[<span class="number">1</span>]),<span class="built_in">id</span>(t1[<span class="number">2</span>])</span><br><span class="line">(<span class="number">4327403152</span>, <span class="number">4327403072</span>, <span class="number">4327422472</span>)</span><br><span class="line">t1[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">111</span> <span class="comment"># 如果元组中存在可变类型，是可以修改，但是修改后的内存地址不变</span></span><br><span class="line">t1</span><br><span class="line">(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, [<span class="number">111</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">id</span>(t1[<span class="number">0</span>]),<span class="built_in">id</span>(t1[<span class="number">1</span>]),<span class="built_in">id</span>(t1[<span class="number">2</span>]) <span class="comment"># 查看id仍然不变</span></span><br><span class="line">(<span class="number">4327403152</span>, <span class="number">4327403072</span>, <span class="number">4327422472</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元类</title>
      <link href="/post/7c613e7d.html"/>
      <url>/post/7c613e7d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-元类介绍"><a href="#一-元类介绍" class="headerlink" title="一 元类介绍"></a>一 元类介绍</h1><p> 什么是元类呢？一切源自于一句话：python中一切皆为对象。 </p> <div class="note simple"><p>元类就是用来实例化产生类的类</p></div><div class="note simple"><p>关系：元类—实例化—-&gt;类（People）—实例化—-&gt;对象（obj）</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s:%s&#x27;</span> %(self.name,self.name))</span><br></pre></td></tr></table></figure><p> 如果说类也是对象,那么People&#x3D;type(……) ,type是内置的元类.我们用class关键字定义的所有的类以及内置的类都是由元类type实例化产生的</p><h1 id="二-class机制分析"><a href="#二-class机制分析" class="headerlink" title="二 class机制分析"></a>二 class机制分析</h1><details class="folding-tag" green><summary> exec用法 </summary>              <div class='content'>              <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exec：三个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数一：包含一系列python代码的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数二：全局作用域（字典形式），如果不指定，默认为globals()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数三：局部作用域（字典形式），如果不指定，默认为locals()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以把exec命令的执行当成是一个函数的执行，会将执行期间产生的名字存放于局部名称空间中</span></span><br><span class="line">g=&#123;</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">l=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">global x,z</span></span><br><span class="line"><span class="string">x=100</span></span><br><span class="line"><span class="string">z=200</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">m=300</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>,g,l)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(g) <span class="comment">#&#123;&#x27;x&#x27;: 100, &#x27;y&#x27;: 2,&#x27;z&#x27;:200,......&#125;</span></span><br><span class="line"><span class="built_in">print</span>(l) <span class="comment">#&#123;&#x27;m&#x27;: 300&#125;</span></span><br></pre></td></tr></table></figure>              </div>            </details><p>class关键字在帮我们创建类时，必然帮我们调用了元类StanfordTeacher&#x3D;type(…)，那调用type时传入的参数是什么呢？必然是类的关键组成部分，一个类有三大组成部分，分别是</p><ul><li><p>类名class_name&#x3D;’People’</p></li><li><p>基类们class_bases&#x3D;(object,)</p></li><li><p>类的名称空间class_dic，类的名称空间是执行类体代码而得到的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class_dic=&#123;&#125;</span><br><span class="line">class_body=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def __init__(self,name,age):</span></span><br><span class="line"><span class="string">    self.name=name</span></span><br><span class="line"><span class="string">    self.age=age</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">def say(self):</span></span><br><span class="line"><span class="string">    print(&#x27;%s:%s&#x27; %(self.name,self.name))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">exec</span>(class_body,&#123;&#125;,class_dic)</span><br><span class="line"><span class="built_in">print</span>(class_dic)</span><br></pre></td></tr></table></figure></li><li><p>调用type时会依次传入以上三个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People=<span class="built_in">type</span>(class_name,class_bases,class_dic)</span><br></pre></td></tr></table></figure></li></ul><h1 id="三-自定义元类来控制类的产生"><a href="#三-自定义元类来控制类的产生" class="headerlink" title="三 自定义元类来控制类的产生"></a>三 自定义元类来控制类的产生</h1><p>先定义一个自己的元类,并且该类必须type元类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>): <span class="comment"># 只有继承了type类的类才是元类</span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">#            空对象,&quot;People&quot;,(),&#123;...&#125;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x,y,z</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run22222222222....&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="comment"># print(x)</span></span><br><span class="line">        <span class="comment"># print(y)</span></span><br><span class="line">        <span class="comment"># print(z)</span></span><br><span class="line">        <span class="comment"># print(y)</span></span><br><span class="line">        <span class="comment"># if not x.istitle():  # 可以写自己的判断逻辑</span></span><br><span class="line">        <span class="comment">#     raise NameError(&#x27;类名的首字母必须大写啊！！！&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#          当前所在的类，调用类时所传入的参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 造Mymeta的对象</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run1111111111.....&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(cls,args,kwargs)</span></span><br><span class="line">        <span class="comment"># return super().__new__(cls,*args, **kwargs)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls,*args, **kwargs)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">       <span class="comment"># 1、Mymeta.__call__函数内会先调用People内的__new__</span></span><br><span class="line">       people_obj=self.__new__(self)</span><br><span class="line">       <span class="comment"># 2、Mymeta.__call__函数内会调用People内的__init__</span></span><br><span class="line">       self.__init__(people_obj,*args, **kwargs)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># print(&#x27;people对象的属性：&#x27;,people_obj.__dict__)</span></span><br><span class="line">       people_obj.__dict__[<span class="string">&#x27;xxxxx&#x27;</span>]=<span class="number">11111</span></span><br><span class="line">       <span class="comment"># 3、Mymeta.__call__函数内会返回一个初始化好的对象</span></span><br><span class="line">       <span class="keyword">return</span> people_obj</span><br></pre></td></tr></table></figure><p>类的产生,People&#x3D;Mymeta(“People”,(object,),{…}),调用Mymeta(调用Mymeta就是调用type.<strong>call</strong>)发生三件事:</p><ul><li>type.<strong>call__函数内会先调用Mymeta内的__new</strong></li><li>type.<strong>call__函数内会调用Mymeta内的__init</strong></li><li>type.__call__函数内会返回一个初始化好的对象</li></ul><p>people类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(metaclass=Mymeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s:%s&#x27;</span> %(self.name,self.name))</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 产生真正的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br></pre></td></tr></table></figure><p>类的调用,obj&#x3D;People(‘lili’,18) &#x3D;》Mymeta.<strong>call</strong>&#x3D;》干了3件事</p><ul><li>Mymeta.<strong>call__函数内会先调用People内的__new</strong></li><li>Mymeta.<strong>call__函数内会调用People内的__init</strong></li><li>Mymeta.__call__函数内会返回一个初始化好的对象</li></ul><h1 id="四-元类下的属性查找"><a href="#四-元类下的属性查找" class="headerlink" title="四 元类下的属性查找"></a>四 元类下的属性查找</h1><p> 在学习完元类后，其实我们用class自定义的类也全都是对象（包括object类本身也是元类type的 一个实例，可以用type(object)查看），我们学习过继承的实现原理，如果把类当成对象去看，将下述继承应该说成是：对象StanfordTeacher继承对象Foo，对象Foo继承对象Bar，对象Bar继承对象object </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>): <span class="comment">#只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span></span><br><span class="line">    n=<span class="number">444</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment">#self=&lt;class &#x27;__main__.StanfordTeacher&#x27;&gt;</span></span><br><span class="line">        obj=self.__new__(self)</span><br><span class="line">        self.__init__(obj,*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    n=<span class="number">333</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">Bar</span>):</span><br><span class="line">    n=<span class="number">222</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StanfordTeacher</span>(Foo,metaclass=Mymeta):</span><br><span class="line">    n=<span class="number">111</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;Stanford&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s says welcome to the Stanford to learn Python&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(StanfordTeacher.n) <span class="comment">#自下而上依次注释各个类中的n=xxx，然后重新运行程序，发现n的查找顺序为StanfordTeacher-&gt;Foo-&gt;Bar-&gt;object-&gt;Mymeta-&gt;type</span></span><br></pre></td></tr></table></figure><p>查找顺序：</p><ul><li>先对象层：StanfordTeacher-&gt;Foo-&gt;Bar-&gt;object</li><li>然后元类层：Mymeta-&gt;type</li></ul><p> 依据上述总结，我们来分析下元类Mymeta中__call__里的self.__new__的查找 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>): </span><br><span class="line">    n=<span class="number">444</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment">#self=&lt;class &#x27;__main__.StanfordTeacher&#x27;&gt;</span></span><br><span class="line">        obj=self.__new__(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__new__ <span class="keyword">is</span> <span class="built_in">object</span>.__new__) <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    n=<span class="number">333</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __new__(cls, *args, **kwargs):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;Bar.__new__&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">Bar</span>):</span><br><span class="line">    n=<span class="number">222</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __new__(cls, *args, **kwargs):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;Foo.__new__&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StanfordTeacher</span>(Foo,metaclass=Mymeta):</span><br><span class="line">    n=<span class="number">111</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;Stanford&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s says welcome to the Stanford to learn Python&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __new__(cls, *args, **kwargs):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;StanfordTeacher.__new__&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StanfordTeacher(<span class="string">&#x27;lili&#x27;</span>,<span class="number">18</span>) <span class="comment">#触发StanfordTeacher的类中的__call__方法的执行，进而执行self.__new__开始查找</span></span><br></pre></td></tr></table></figure><p> 总结，</p><ul><li>Mymeta下的__call__里的self.<strong>new__在StanfordTeacher、Foo、Bar里都没有找到__new__的情况下，会去找object里的__new__，而object下默认就有一个__new__，所以即便是之前的类均未实现__new</strong>,也一定会在object中找到一个，根本不会、也根本没必要再去找元类Mymeta-&gt;type中查找__new__ </li><li>我们在元类的__call__中也可以用object.<strong>new</strong>(self)去造对象 </li><li>但我们还是推荐在__call__中使用self.<strong>new</strong>(self)去创造空对象，因为这种方式会检索三个类StanfordTeacher-&gt;Foo-&gt;Bar,而object.__new__则是直接跨过了他们三个</li></ul><p>最后说明一点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>): <span class="comment">#只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类</span></span><br><span class="line">    n=<span class="number">444</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        obj=<span class="built_in">type</span>.__new__(cls,*args,**kwargs) <span class="comment"># 必须按照这种传值方式</span></span><br><span class="line">        <span class="built_in">print</span>(obj.__dict__)</span><br><span class="line">        <span class="comment"># return obj # 只有在返回值是type的对象时，才会触发下面的__init__</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,class_name,class_bases,class_dic</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run。。。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StanfordTeacher</span>(<span class="built_in">object</span>,metaclass=Mymeta): <span class="comment">#StanfordTeacher=Mymeta(&#x27;StanfordTeacher&#x27;,(object),&#123;...&#125;)</span></span><br><span class="line">    n=<span class="number">111</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;Stanford&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s says welcome to the Stanford to learn Python&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Mymeta)) <span class="comment">#&lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 产生类StanfordTeacher的过程就是在调用Mymeta，而Mymeta也是type类的一个对象，那么Mymeta之所以可以调用，一定是在元类type中有一个__call__方法</span></span><br><span class="line"><span class="comment"># 该方法中同样需要做至少三件事：</span></span><br><span class="line"><span class="comment"># class type:</span></span><br><span class="line"><span class="comment">#     def __call__(self, *args, **kwargs): #self=&lt;class &#x27;__main__.Mymeta&#x27;&gt;</span></span><br><span class="line"><span class="comment">#         obj=self.__new__(self,*args,**kwargs) # 产生Mymeta的一个对象</span></span><br><span class="line"><span class="comment">#         self.__init__(obj,*args,**kwargs) </span></span><br><span class="line"><span class="comment">#         return obj</span></span><br></pre></td></tr></table></figure><h1 id="五-基于元类实现单例模式"><a href="#五-基于元类实现单例模式" class="headerlink" title="五 基于元类实现单例模式"></a>五 基于元类实现单例模式</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单例：即单个实例，指的是同一个类实例化多次的结果指向同一个对象，用于节省内存空间</span></span><br><span class="line"><span class="comment"># 如果我们从配置文件中读取配置来进行实例化，在配置相同的情况下，就没必要重复产生对象浪费内存了</span></span><br><span class="line"><span class="comment">#settings.py文件内容如下</span></span><br><span class="line">HOST=<span class="string">&#x27;1.1.1.1&#x27;</span></span><br><span class="line">PORT=<span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方式一:定义一个类方法实现单例模式</span></span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mysql</span>:</span><br><span class="line">    __instance=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,host,port</span>):</span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">            cls.__instance=cls(settings.HOST,settings.PORT)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">obj1=Mysql(<span class="string">&#x27;1.1.1.2&#x27;</span>,<span class="number">3306</span>)</span><br><span class="line">obj2=Mysql(<span class="string">&#x27;1.1.1.3&#x27;</span>,<span class="number">3307</span>)</span><br><span class="line"><span class="built_in">print</span>(obj1 <span class="keyword">is</span> obj2) <span class="comment">#False</span></span><br><span class="line"></span><br><span class="line">obj3=Mysql.singleton()</span><br><span class="line">obj4=Mysql.singleton()</span><br><span class="line"><span class="built_in">print</span>(obj3 <span class="keyword">is</span> obj4) <span class="comment">#True</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方式二：定制元类实现单例模式</span></span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,bases,dic</span>): <span class="comment">#定义类Mysql时就触发</span></span><br><span class="line">        <span class="comment"># 事先先从配置文件中取配置来造一个Mysql的实例出来</span></span><br><span class="line">        self.__instance = <span class="built_in">object</span>.__new__(self)  <span class="comment"># 产生对象</span></span><br><span class="line">        self.__init__(self.__instance, settings.HOST, settings.PORT)  <span class="comment"># 初始化对象</span></span><br><span class="line">        <span class="comment"># 上述两步可以合成下面一步</span></span><br><span class="line">        <span class="comment"># self.__instance=super().__call__(*args,**kwargs)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name,bases,dic)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment">#Mysql(...)时触发</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">or</span> kwargs: <span class="comment"># args或kwargs内有值</span></span><br><span class="line">            obj=<span class="built_in">object</span>.__new__(self)</span><br><span class="line">            self.__init__(obj,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mysql</span>(metaclass=Mymeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,host,port</span>):</span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"></span><br><span class="line">obj1=Mysql() <span class="comment"># 没有传值则默认从配置文件中读配置来实例化，所有的实例应该指向一个内存地址</span></span><br><span class="line">obj2=Mysql()</span><br><span class="line">obj3=Mysql()</span><br><span class="line"><span class="built_in">print</span>(obj1 <span class="keyword">is</span> obj2 <span class="keyword">is</span> obj3)</span><br><span class="line">obj4=Mysql(<span class="string">&#x27;1.1.1.4&#x27;</span>,<span class="number">3307</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方式三:定义一个装饰器实现单例模式</span></span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>): <span class="comment">#cls=Mysql</span></span><br><span class="line">    _instance=cls(settings.HOST,settings.PORT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">or</span> kwargs:</span><br><span class="line">            obj=cls(*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        <span class="keyword">return</span> _instance</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton </span><span class="comment"># Mysql=singleton(Mysql)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mysql</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,host,port</span>):</span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"></span><br><span class="line">obj1=Mysql()</span><br><span class="line">obj2=Mysql()</span><br><span class="line">obj3=Mysql()</span><br><span class="line"><span class="built_in">print</span>(obj1 <span class="keyword">is</span> obj2 <span class="keyword">is</span> obj3) <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">obj4=Mysql(<span class="string">&#x27;1.1.1.3&#x27;</span>,<span class="number">3307</span>)</span><br><span class="line">obj5=Mysql(<span class="string">&#x27;1.1.1.4&#x27;</span>,<span class="number">3308</span>)</span><br><span class="line"><span class="built_in">print</span>(obj3 <span class="keyword">is</span> obj4) <span class="comment">#False</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成器</title>
      <link href="/post/2178aef8.html"/>
      <url>/post/2178aef8.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-生成器与yield"><a href="#1-生成器与yield" class="headerlink" title="1.生成器与yield"></a>1.生成器与yield</h1><ul><li>若函数体包含yield关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象</li></ul>  <div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>注意的是,函数体内有yield关键字不能说该函数就是生成器,好好体会上面这句话</p></div>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">start,stop,step=<span class="number">1</span></span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> start &lt; stop:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> start</span><br><span class="line"><span class="meta">... </span>        start+=step</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;end...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=my_range(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> my_range at <span class="number">0x104105678</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>生成器内置有__iter__和__next__方法，所以生成器本身就是一个特殊的迭代器 </p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__iter__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__iter__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__next__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__next__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行直到遇到yield则停止,将yield后的值返回，并在当前位置挂起函数</span></span><br><span class="line">start...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 再次调用next(g)，函数从上次暂停的位置继续执行，直到重新遇到yield...</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 周而复始...</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行没有遇到yield则无值返回，即取值完毕抛出异常结束迭代</span></span><br><span class="line">end...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><h1 id="2-yield表达式的应用"><a href="#2-yield表达式的应用" class="headerlink" title="2.yield表达式的应用"></a>2.yield表达式的应用</h1><h2 id="1-在函数内可以采用表达式形式的yield"><a href="#1-在函数内可以采用表达式形式的yield" class="headerlink" title="1.在函数内可以采用表达式形式的yield"></a>1.在函数内可以采用表达式形式的yield</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">eater</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        food=<span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> %food)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​     可以拿到函数的生成器对象持续为函数体send值，如下 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=eater() <span class="comment"># 得到生成器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> eater at <span class="number">0x101b6e2b0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(e) <span class="comment"># 需要事先”初始化”一次，让函数挂起在food=yield，等待调用g.send()方法为其传值</span></span><br><span class="line">Ready to eat</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="string">&#x27;包子&#x27;</span>)</span><br><span class="line">get the food: 包子, <span class="keyword">and</span> start to eat</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="string">&#x27;鸡腿&#x27;</span>)</span><br><span class="line">get the food: 鸡腿, <span class="keyword">and</span> start to eat</span><br></pre></td></tr></table></figure><pre><code>  针对表达式形式的yield，生成器对象必须事先被初始化一次，让函数挂起在food=yield的位置，等待调用g.send()方法为函数体传值g.send(None)等同于next(g)。 </code></pre><h2 id="2-编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作"><a href="#2-编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作" class="headerlink" title="2.编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作"></a>2.编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        g=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@init</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eater</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food=<span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> %food)</span><br></pre></td></tr></table></figure><h2 id="3-yield返回值"><a href="#3-yield返回值" class="headerlink" title="3.yield返回值"></a>3.yield返回值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">eater</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    food_list=[]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        food=<span class="keyword">yield</span> food_list</span><br><span class="line"><span class="meta">... </span>        food_list.append(food)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e=eater()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(e)</span><br><span class="line">Ready to eat</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸羊羔&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸熊掌&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸鹿尾儿&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>, <span class="string">&#x27;蒸鹿尾儿&#x27;</span>]</span><br></pre></td></tr></table></figure><h1 id="3-其他生成式"><a href="#3-其他生成式" class="headerlink" title="3.其他生成式"></a>3.其他生成式</h1><h2 id="3-1-三元表达式"><a href="#3-1-三元表达式" class="headerlink" title="3.1 三元表达式"></a>3.1 三元表达式</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max2</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">res = max2(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># res = 条件成立时返回的值 if 条件 else 条件不成立时返回的值</span></span><br><span class="line">res = x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y <span class="comment"># 三元表达式</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="3-2-列表生成式"><a href="#3-2-列表生成式" class="headerlink" title="3.2 列表生成式"></a>3.2 列表生成式</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[expression <span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1 <span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2 <span class="keyword">if</span> condition2</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN <span class="keyword">if</span> conditionN</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#类似于</span></span><br><span class="line">res=[]</span><br><span class="line"><span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1:</span><br><span class="line">    <span class="keyword">if</span> condition1:</span><br><span class="line">        <span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2:</span><br><span class="line">            <span class="keyword">if</span> condition2</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN:</span><br><span class="line">                    <span class="keyword">if</span> conditionN:</span><br><span class="line">                        res.append(expression)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egg_list=[ i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="3-3-生成器表达式"><a href="#3-3-生成器表达式" class="headerlink" title="3.3 生成器表达式"></a>3.3 生成器表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=(x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x101be0ba0</span>&gt;</span><br></pre></td></tr></table></figure><p>​      <div class="note icon simple"><i class="note-icon fab fa-cc-visa"></i><p>对比列表生成式，生成器表达式的优点自然是节省内存（一次只产生一个值在内存中）</p></div></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p> 如果我们要读取一个大文件的字节数，应该基于生成器表达式的方式完成 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    nums=(<span class="built_in">len</span>(line) <span class="keyword">for</span> line <span class="keyword">in</span> f)</span><br><span class="line">    total_size=<span class="built_in">sum</span>(nums) <span class="comment"># 依次执行next(nums)，然后累加到一起得到结果=</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/post/2cf69f40.html"/>
      <url>/post/2cf69f40.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h1> <div class="note simple"><p>提示块标签迭代器即用来迭代取值的工具，而迭代是重复反馈过程的活动，其目的通常是为了逼近所需的目标或结果，每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值,单纯的重复并不是迭代 </p></div><h2 id="1-1-可迭代对象"><a href="#1-1-可迭代对象" class="headerlink" title="1.1 可迭代对象"></a>1.1 可迭代对象</h2><p>通过索引的方式进行迭代取值，实现简单，但仅适用于序列类型：字符串，列表，元组。对于没有索引的字典、集合等非序列类型，必须找到一种不依赖索引来进行迭代取值的方式，这就用到了迭代器。</p><p>要想了解迭代器为何物，必须事先搞清楚一个很重要的概念：可迭代对象(Iterable)。从语法形式上讲，内置有__iter__方法的对象都是可迭代对象，字符串、列表、元组、字典、集合、打开的文件都是可迭代对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;egon&#x27;</span>&#125;.__iter__</span><br><span class="line">&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;.__iter__</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="1-2-迭代器对象"><a href="#1-2-迭代器对象" class="headerlink" title="1.2 迭代器对象"></a>1.2 迭代器对象</h2><div class="note modern"><p>调用obj.<strong>iter</strong>()方法返回的结果就是一个迭代器对象(Iterator)。迭代器对象是内置有<strong>iter</strong>和<strong>next</strong>方法的对象，打开的文件本身就是一个迭代器对象，执行迭代器对象.<strong>iter</strong>()方法得到的仍然是迭代器本身，而执行迭代器.<strong>next</strong>()方法就会计算出迭代器中的下一个值。 迭代器是Python提供的一种统一的、不依赖于索引的迭代取值方式，只要存在多个“值”，无论序列类型还是非序列类型都可以按照迭代器的方式取值</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment"># 可迭代对象s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i=<span class="built_in">iter</span>(s)  <span class="comment"># 本质就是在调用s.__iter__(),返回s的迭代器对象i，</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i) <span class="comment"># 本质就是在调用i.__next__()</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(i)  <span class="comment">#抛出StopIteration的异常，代表无值可取，迭代结束</span></span><br></pre></td></tr></table></figure><h1 id="for循环原理"><a href="#for循环原理" class="headerlink" title="for循环原理"></a>for循环原理</h1><div class='wow animate__flip' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' ><div class="note green icon modern"><i class="note-icon fas fa-fan"></i><p> 有了迭代器后，我们便可以不依赖索引迭代取值了，使用while循环的实现方式如下 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line">i=<span class="built_in">iter</span>(goods) <span class="comment">#每次都需要重新获取一个迭代器对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(i))</span><br><span class="line">    <span class="keyword">except</span> StopIteration: <span class="comment">#捕捉异常终止循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div></div> <div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon modern"><i class="note-icon fas fa-bullhorn"></i><p>for循环又称为迭代循环，in后可以跟任意可迭代对象，上述while循环可以简写为 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> goods:   </span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure></div></div><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal"> for 循环在工作时，首先会调用可迭代对象goods内置的**iter**方法拿到一个迭代器对象，然后再调用该迭代器对象的**next**方法将取到的值赋给item,执行循环体完成一次循环，周而复始，直到捕捉StopIteration异常，结束迭代。 </p></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器</title>
      <link href="/post/da520e93.html"/>
      <url>/post/da520e93.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>装饰器的作用</p><p class='p cyan'>软件的设计应该遵循开放封闭原则，即对扩展是开放的，而对修改是封闭的。对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着对象一旦设计完成，就可以独立完成其工作，而不要对其进行修改。</p><p class='p blue'>软件包含的所有功能的源代码以及调用方式，都应该避免修改，否则一旦改错，则极有可能产生连锁反应，最终导致程序崩溃，而对于上线后的软件，新需求或者变化又层出不穷，我们必须为程序提供扩展的可能性，这就用到了装饰器。</p></li></ul><div class="note simple"><p>函数装饰器分为：无参装饰器和有参装饰两种，二者的实现原理一样，都是’函数嵌套+闭包+函数对象’的组合使用的产物。 </p></div><h1 id="无参装饰器"><a href="#无参装饰器" class="headerlink" title="无参装饰器"></a>无参装饰器</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p> 实现一个无参装饰器timer，可以在不修改被装饰对象index源代码和调用方式的前提下为其加上新功能。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个timer装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通函数index,home</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the index page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the home page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p> 此时我们就可以用timer来装饰带参数或不带参数的函数了 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer </span><span class="comment"># index=timer(index)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the index page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p> 如果我们有多个装饰器，可以叠加多个 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@deco3</span></span><br><span class="line"><span class="meta">@deco2</span></span><br><span class="line"><span class="meta">@deco1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p> 叠加多个装饰器无特殊之处，上述代码语义如下 </p><div class="note simple"><p>index&#x3D;deco3(deco2(deco1(index)))</p></div><div class="tip warning faa-horizontal animated"><p>注意的是,多个装饰器装饰的顺序从下倒上,执行顺序从上到下</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="有参装饰器"><a href="#有参装饰器" class="headerlink" title="有参装饰器"></a>有参装饰器</h1><ul><li>如果我们想提供多种不同的认证方式以供选择 ,如下 函数wrapper需要一个driver参数，而函数deco与wrapper的参数都有其特定的功能，不能用来接受其他类别的参数，可以在deco的外部再包一层函数auth，用来专门接受额外的参数，这样便保证了在auth函数内无论多少层都可以引用到</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">auth</span>(<span class="params">driver</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> driver == <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">                编写基于文件的认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">            <span class="keyword">elif</span> driver == <span class="string">&#x27;mysql&#x27;</span>:</span><br><span class="line">                编写基于mysql认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> deco</span><br></pre></td></tr></table></figure><ul><li>此时我们就实现了一个有参装饰器，使用方式如下</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先调用auth(driver=&#x27;file&#x27;)，得到@deco，deco是一个闭包函数，</span></span><br><span class="line"><span class="comment">#包含了对外部作用域名字driver的引用，@deco的语法意义与无参装饰器一样</span></span><br><span class="line"><span class="meta">@auth(<span class="params">driver=<span class="string">&#x27;file&#x27;</span></span>) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():     </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@auth(<span class="params">driver=<span class="string">&#x27;mysql&#x27;</span></span>) </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    <span class="keyword">pass</span>  </span><br></pre></td></tr></table></figure><ul><li><p>此外,因为index已经不是原来那个index了,而是wrapper函数.如果我们想要被装饰的index函数任然看起来跟原始的index函数看起来一摸一样,那么我们可以简单的包装”wraps”一下.</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p> 在被装饰之后home&#x3D;wrapper,查看home.<strong>name</strong>也可以发现home的函数名确实是wrapper，想要保留原函数的文档和函数名属性，需要修正装饰器 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    wrapper.__doc__=func.__doc__</span><br><span class="line">    wrapper.__name__=func.__name__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p> 按照上述方式来实现保留原函数属性过于麻烦，functools模块下提供一个装饰器wraps专门用来帮我们实现这件事，用法如下 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变与不可变类型</title>
      <link href="/post/4e9b1069.html"/>
      <url>/post/4e9b1069.html</url>
      
        <content type="html"><![CDATA[<h1 id="可变数据类型"><a href="#可变数据类型" class="headerlink" title="可变数据类型"></a><strong>可变数据类型</strong></h1><p>值发生改变时，内存地址不变，即id不变，证明在改变原值</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;egon&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(list1)</span><br><span class="line"><span class="number">486316639176</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1[<span class="number">2</span>] = <span class="string">&#x27;kevin&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(list1)</span><br><span class="line"><span class="number">486316639176</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1.append(<span class="string">&#x27;lili&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(list1)</span><br><span class="line"><span class="number">486316639176</span></span><br><span class="line"><span class="comment"># 对列表的值进行操作时，值改变但内存地址不变，所以列表是可变数据类型</span></span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/dbt2eRVYfCUKk85.png" alt="1663491472029"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/S8n2Q4sWRefxHwu.png" alt="1663491493828"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/qidjSl9cwETQ1Lf.png" alt="1663491545185"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(dic)</span><br><span class="line"><span class="number">4327423112</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic[<span class="string">&#x27;age&#x27;</span>]=<span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;egon&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(dic)</span><br><span class="line"><span class="number">4327423112</span></span><br><span class="line"><span class="comment"># 对字典进行操作时，值改变的情况下，字典的id也是不变，即字典也是可变数据类型</span></span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/i8EDMhZqmO6YPUI.png" alt="1663491806354"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/4ZBTUOzo7tfxRhs.png" alt="1663491828358"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="不可变类型"><a href="#不可变类型" class="headerlink" title="不可变类型"></a><strong>不可变类型</strong></h1><p>值发生改变时，内存地址也发生改变，即id也变，证明是没有在改变原值，是产生了新的值</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a><strong>数字类型</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">1830448896</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">1830448928</span></span><br><span class="line"><span class="comment"># 内存地址改变了，说明整型是不可变数据类型，浮点型也一样</span></span><br></pre></td></tr></table></figure><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/zs3tOI2AmiQghBa.png" alt="1663490793653"></p>              </div>            </details><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&quot;Jy&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">938809263920</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&quot;Ricky&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(x)</span><br><span class="line"><span class="number">938809264088</span></span><br><span class="line"><span class="comment"># 内存地址改变了，说明字符串是不可变数据类型</span></span><br></pre></td></tr></table></figure><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/Vc3x2pIwTYtnf5B.png" alt="1663491001856"></p>              </div>            </details><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">0</span>]=<span class="string">&#x27;TOM&#x27;</span> <span class="comment"># 报错：TypeError</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1.append(<span class="string">&#x27;lili&#x27;</span>) <span class="comment"># 报错：TypeError</span></span><br><span class="line"><span class="comment"># 元组内的元素无法修改，指的是元组内索引指向的内存地址不能被修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t1[<span class="number">0</span>]),<span class="built_in">id</span>(t1[<span class="number">1</span>]),<span class="built_in">id</span>(t1[<span class="number">2</span>])</span><br><span class="line">(<span class="number">4327403152</span>, <span class="number">4327403072</span>, <span class="number">4327422472</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">111</span> <span class="comment"># 如果元组中存在可变类型，是可以修改，但是修改后的内存地址不变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1</span><br><span class="line">(<span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, [<span class="number">111</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t1[<span class="number">0</span>]),<span class="built_in">id</span>(t1[<span class="number">1</span>]),<span class="built_in">id</span>(t1[<span class="number">2</span>]) <span class="comment"># 查看id仍然不变</span></span><br><span class="line">(<span class="number">4327403152</span>, <span class="number">4327403072</span>, <span class="number">4327422472</span>)</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/GsNM3efjgqOxz8V.png" alt="1663491674673"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/09/18/NRWbp6SrDK4ze5F.png" alt="1663491711256"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数据类型总结"><a href="#数据类型总结" class="headerlink" title="数据类型总结"></a>数据类型总结</h1><ol><li><div class='wow animate__flip' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' >   <div class="note green icon modern"><i class="note-icon fas fa-fan"></i><p>按存值个数区分</p></div>   </div><p>只能存一个值: 字符串,数字</p><p>可以存多个值(容器类型):列表,元祖,字典</p><p>​</p></li><li><div class='wow animate__flipInX' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' >   <div class="note green icon modern"><i class="note-icon fas fa-fan"></i><p>按访问方式区分</p></div>   </div><p>直接访问: 数字</p><p>顺序访问: 列表,元祖,字符串</p><p>key访问: 字典</p></li><li><div class='wow animate__flipInY' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' >   <div class="note green icon modern"><i class="note-icon fas fa-fan"></i><p>按可变与不可变区分</p></div>   </div><p> 可变: 列表,字典</p><p>不可变: 字符串,元祖,数字</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3</title>
      <link href="/post/3a42db2d.html"/>
      <url>/post/3a42db2d.html</url>
      
        <content type="html"><![CDATA[<p>之前写了一篇关于 Vue2 的后台管理系统模板的推荐，详情请见 Vue后台管理系统模板推荐。</p><p>Vue3 在今年2月份已成为新的默认版本，本文收集了一些 Vue3 的后台管理系统模板，分享给在座的仌（打工人乃人上人👣）。</p><p>还是老规矩，按照 Github 星标数量来依次介绍。</p><p>个人较推荐 vue-vben-admin、vue-pure-admin、naive-ui-admin、vue3-composition-admin、vue-next-admin。意见仅供参考，具体可根据团队审美，业务需求选择一款更契合的后台管理系统模板。</p><p>gin-vue-admin (14.2k)<br>如果后台选择的是go语言，可以考虑这一款。</p><p>gin-vue-admin（github上的标星数为14.2k）基于 vite + vue3 + gin 搭建的开发基础平台（支持TS，JS 混用），集成 jwt鉴权，权限管理，动态路由，显隐可控组件，分页封装，多点登录拦截，资源权限，上传下载，代码生成器，表单生成器等开发必备功能。</p><p>相关地址<br>文档地址：gin-vue-admin Documentation<br>仓库地址：<a href="https://github.com/flipped-aurora/gin-vue-admin">https://github.com/flipped-aurora/gin-vue-admin</a><br>预览地址：<a href="http://demo.gin-vue-admin.com/">http://demo.gin-vue-admin.com</a><br>技术选型<br>前端：用基于 Vue 的 Element 构建基础页面。<br>后端：用 Gin 快速搭建基础 restful风格API，Gin 是一个go语言编写的Web框架。<br>数据库：采用MySql&gt;5.7版本，数据库引擎 innoDB，使用 gorm 实现对数据库的基本操作，已添加对sqlite数据库的支持。<br>缓存：使用Redis实现记录当前活跃用户的jwt令牌并实现多点登录限制。<br>API文档：使用Swagger构建自动化文档。<br>配置文件：使用 fsnotify 和 viper 实现yaml格式的配置文件。<br>日志：使用 zap 实现日志记录。<br>主要功能<br>权限管理：基于jwt和casbin实现的权限管理<br>用户管理：系统管理员分配用户角色和角色权限。<br>角色管理：创建权限控制的主要对象，可以给角色分配不同api权限和菜单权限。<br>菜单管理：实现用户动态菜单配置，实现不同角色不同菜单。<br>api管理：不同用户可调用的api接口的权限不同。<br>富文本编辑器：MarkDown编辑器功能嵌入。<br>restful示例：可以参考用户管理模块中的示例API。<br>多点登录限制：需要在config.yaml中把system中的useMultipoint修改为true(需要自行配置Redis和Config中的Redis参数，测试阶段，有bug请及时反馈)。<br>表单生成器：表单生成器借助 @form-generator。<br>代码生成器：后台基础逻辑以及简单curd的代码生成器等。<br>预览效果</p><p>vue-vben-admin (13.5k)<br>Vue-Vben-Admin（github上的标星数为13.5k）是一个基于 Vue3.0、Vite、 Ant-Design-Vue、TypeScript 的后台解决方案，目标是为开发中大型项目提供开箱即用的解决方案。包括二次封装组件、utils、hooks、动态菜单、权限校验、按钮级别权限控制等功能。项目使用前端较新的技术栈，可以作为项目的启动模版，以帮助你快速搭建企业级中后台产品原型。</p><p>相关地址<br>文档地址：Vben Admin Documentation<br>仓库地址：完整版、简化版<br>预览地址：完整版、简化版<br>特点<br>最新技术栈：使用 Vue3&#x2F;vite2 等前端前沿技术开发<br>TypeScript: 应用程序级 JavaScript 的语言<br>主题：可配置的主题<br>国际化：内置完善的国际化方案<br>Mock 数据 内置 Mock 数据方案<br>权限 内置完善的动态路由权限生成方案<br>组件 二次封装了多个常用的组件<br>预览效果</p>]]></content>
      
      
      <categories>
          
          <category> 前段Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/16107.html"/>
      <url>/post/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
